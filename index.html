<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Glyphtrix</title>
  <link href="https://cdn.jsdelivr.net/npm/remixicon@4.2.0/fonts/remixicon.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Victor+Mono:wght@400;700&family=Source+Code+Pro:wght@400;700&family=Bytesized:wght@400&family=VT323&family=Cutive+Mono&family=Doto:wght@100..900&family=Workbench:wght@400&display=swap');

    :root {
      /* Primary Colors */
      --primary-bg: #000;
      --primary-text: #fff;
      --primary-white: #FFFFFF;
      
      /* Border Colors */
      --border-primary: #555;
      --border-secondary: #333;
      --border-light: #111;
      
      /* Hover States */
      --hover-grey: #1d1d1d;
      --hover-red: #440000;
      --hover-red-dark: #660000;
      
      /* Status Colors */
      --error-text: #FF6666;
      --muted-grey: #636363;
      --dark-grey: #111111;
      --disabled-red: #220000;
      
      /* Accent Colors */
      --accent-dark: #111;
      --overlay-bg: rgba(0, 0, 0, 0.8);
      --overlay-dark: rgba(0, 0, 0, 0.85);
      
      /* Drag States */
      --drag-hover: #444;
      --drag-default: #333;
    }

    *, *::before, *::after {
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      font-family: "Courier New", Courier, monospace;
      background-color: var(--primary-bg);
      color: var(--primary-text);
    }

    body {
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
    }

    .container {
      display: flex;
      width: 100%;
      background-color: var(--primary-bg);
      overflow: hidden;
      flex-grow: 1;
    }

    .input-column, .output-column {
      width: 50%;
      height: 100%;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      position: relative;
      min-height: 0;
      overflow: hidden;
    }

    .input-column {
      border-right: 1px solid var(--border-primary);
    }

    .column-header {
      height: auto;
      min-height: 75px;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      box-sizing: border-box;
      border-bottom: 1px solid var(--border-primary);
      flex-shrink: 0;
      position: relative;
    }
    .column-header h2 {
        display: flex;
        align-items: center;
    }
          #loadingSpinner {
        position: absolute;
        right: 20px;
        top: 50%;
        transform: translateY(-50%);
      }
      
      #mobileLoadingSpinner {
        position: absolute;
        right: 20px;
        top: 50%;
        transform: translateY(-50%);
      }
    #sequenceLoadingMessage {
        font-size: 0.9em;
        margin-top: 5px;
        text-align: center;
        width: 100%;
        position: absolute;
        bottom: -25px;
    }


    .input-area {
      width: 100%;
      height: calc(100% - 100px);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      flex-grow: 1;
      position: relative;
      min-height: 0;
      overflow: hidden;
    }

    .input-area input[type="file"] {
      display: none;
    }

    .imageCanvas, #inputVideo {
      width: 100%;
      max-width: 100%;
      object-fit: contain;
      flex-grow: 1;
      border: none;
      min-height: 500px;
    }
    #inputVideo { display: none; }


    #outputCanvas {
      background-color: var(--primary-bg);
      width: 100%;
      max-width: 100%;
      height: calc(100% - 100px);
      object-fit: contain;
      flex-grow: 1;
      border: none;
      min-height: 500px;
    }
    #sequenceLoadingOverlay {
        position: absolute;
        top: 100px;
        left: 0;
        width: 100%;
        height: calc(100% - 100px);
        background-color: var(--overlay-dark);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10;
    }
    #sequenceLoadingSpinner svg {
        fill: var(--primary-text);
    }
    #sequenceLoadingOverlay p {
        margin-top: 15px;
        font-size: 1.2em;
        color: var(--primary-text);
    }
    #cancelSequenceButton {
        background-color: var(--hover-red);
        color: var(--error-text);
        border: 1px solid var(--error-text);
        padding: 8px 15px;
        font-size: 0.9em;
        cursor: pointer;
        border-radius: 3px;
        margin-top: 20px;
    }
    #cancelSequenceButton:hover {
        background-color: var(--hover-red-dark);
    }


    .upload-zone {
      border: 4px dashed var(--border-primary);
      width: 80%;
      height: 80%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .upload-zone:hover {
      background-color: var(--hover-grey);
    }

    .upload-zone i {
      font-size: 3em;
      margin-bottom: 10px;
    }

    .upload-zone span {
      text-align: center;
    }

    .upload-zone.loading i {
      display: none;
    }

    .upload-zone.loading .upload-spinner {
      display: inline-block;
      font-size: 3em;
      margin-bottom: 10px;
    }

    .upload-zone .upload-spinner {
      display: none;
    }

    .example-buttons-container {
      display: flex;
      gap: 10px;
      margin-top: 15px;
      justify-content: center;
      width: 100%;
    }

    .example-buttons-container .btn-action {
      min-width: 160px;
      justify-content: center;
      padding: 8px 12px;
      font-size: 0.9em;
    }

    .settings-panel-container {
      width: 100%;
      min-height: 200px;
      height: auto;
      background-color: var(--primary-bg);
      display: flex;
      align-items: stretch;
      justify-content: space-between;
      box-sizing: border-box;
      border-top: 1px solid var(--border-primary);
      flex-shrink: 0;
      overflow-x: hidden;
    }

    .settings-panel-section-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      padding: 1rem;
      overflow-y: auto;
      min-width: 150px;
      font-size: 1em;
    }
     .upload-panel-content {
        flex-grow: 0.4; align-items: flex-start;
        border-right: 1px solid var(--border-primary);
        min-width: 180px; width: 100%; box-sizing: border-box; overflow: hidden;
        position: relative;
     }
     .download-panel-content {
        flex-grow: 0.8;
        align-items: flex-start;
        border-left: 1px solid var(--border-primary);
        min-width: 280px;
     }
     .settings-title-section {
        flex-grow: 0.1; flex-shrink: 0; flex-basis: auto;
        align-items: flex-start; justify-content: flex-start; padding-right: 0;
     }
     .settings-image-content {
        flex-grow: 1.5;
        align-items: flex-start;
     }
     .settings-font-content {
        flex-grow: 1;
        align-items: flex-start;
        min-width: 220px;
     }
     .settings-output-content {
        flex-grow: 0.7;
        align-items: flex-start;
        min-width: 160px;
     }


    .settings-panel-section-content h2 {
        font-size: 1.3em;
        margin: 0 0 10px 0;
        width: 100%;
        text-align: left;
        box-sizing: border-box;
    }
    .upload-panel-content > h2.initially-hidden {
        display: none;
    }


    .image-settings-layout, .output-settings-layout, .font-settings-layout {
        display: flex;
        justify-content: space-between;
        width: 100%;
        gap: 1rem;
    }
    .font-settings-layout {
        gap: 1rem;
    }
    .settings-column {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: flex-start;
    }


    .slider-container, .control-container, .checkbox-container, .reset-button-container {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        margin-bottom: 10px;
        max-width: 180px;
    }
    .checkbox-container {
        flex-direction: row;
        align-items: center;
        margin-top: 5px;
    }
    .checkbox-container input[type="checkbox"] {
        margin-right: 8px; width: 16px; height: 16px; accent-color: var(--primary-text);
        background-color: var(--border-secondary); border: 1px solid var(--border-primary); cursor: pointer;
        -webkit-appearance: none; -moz-appearance: none; appearance: none;
        border-radius: 3px; position: relative;
    }
    .checkbox-container input[type="checkbox"]:checked {
        background-color: var(--hover-grey); border-color: var(--primary-text);
    }
    .checkbox-container input[type="checkbox"]:checked::before {
        content: '\2713'; font-size: 12px; color: var(--primary-text);
        position: absolute; left: 2px; top: 0px;
    }
    .checkbox-container label { font-size: 0.85em; cursor: pointer; }


    .control-container label { margin-bottom: 5px; font-size: 0.85em; white-space: nowrap; }
     .control-container select, .select-group select {
        background-color: var(--primary-bg);
        color: var(--primary-text);
        border: 1px solid var(--border-primary);
        padding: 5px;
        width: 100%;
        font-family: inherit;
        height: 28px;
        max-width: 180px;
     }
    .select-group select {
        flex-grow: 1;
        margin: 0;
    }
    .control-container input[type="text"] {
        background-color: var(--primary-bg);
        color: var(--primary-text);
        border: 1px solid var(--border-primary);
        padding: 5px;
        width: 100%;
        font-family: inherit;
        margin-top: 3px;
        height: 28px;
    }
    .control-container input[type="text"]:disabled {
        background-color: var(--border-secondary);
        color: var(--muted-grey);
        cursor: not-allowed;
    }
    #customCharsHelpButton:disabled {
        background-color: var(--border-secondary);
        color: var(--muted-grey);
        cursor: not-allowed;
        border-color: var(--border-secondary);
    }



    .input-group, .select-group {
        display: flex; align-items: center; width: 100%; max-width: 180px;
    }
    .select-group {
        gap: 0px;
    }
    .input-group button, .select-group button {
        padding: 5px 8px;
        font-size: 1em;
        height: 28px;
        flex-shrink: 0;
        margin: 0;
    }
    .input-group input[type="number"] {
        width: 50px;
        text-align: center;
        background-color: var(--primary-bg);
        color: var(--primary-text);
        border: 1px solid var(--border-primary);
        padding: 3px;
        height: 28px;
        -moz-appearance: textfield;
        margin: 0 3px;
    }
    .input-group input[type=number]::-webkit-outer-spin-button,
    .input-group input[type=number]::-webkit-inner-spin-button {
        -webkit-appearance: none; margin: 0;
    }

    .slider-container label {
        display: flex; justify-content: space-between; width: 100%;
        margin-bottom: 10px; font-size: 0.85em; white-space: nowrap;
    }
          .slider-container label span { margin-left: 5px; color: var(--primary-text); }
      
      #gridSizeDisplay, #outputResolutionDisplay {
        display: inline-block;
        margin-top: 5px;
      }

    input[type="range"] {
        -webkit-appearance: none; appearance: none; width: 100%;
        height: 8px; background: var(--border-secondary); outline: none; opacity: 0.7;
        transition: opacity .15s ease-in-out; border-radius: 4px;
    }
    input[type="range"]:hover { opacity: 1; }
    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none; appearance: none; width: 16px; height: 16px;
        background: var(--primary-text); cursor: pointer; border-radius: 50%; border: 1px solid var(--primary-bg);
    }
    input[type="range"]::-moz-range-thumb {
        width: 16px; height: 16px; background: var(--primary-text); cursor: pointer;
        border-radius: 50%; border: 1px solid var(--primary-bg);
    }



    .condensed-upload-zone {
      border: 2px dashed var(--border-primary);
      padding: 8px;
      cursor: pointer;
      display: block;
      transition: background-color 0.2s;
      width: 100%;
      overflow: hidden;
    }
     .condensed-upload-zone:hover { background-color: var(--hover-grey); }
    .condensed-upload-zone input[type="file"] { display: none; }
    .condensed-upload-zone label {
        cursor: pointer;
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        padding: 3px;
        width: 100%;
    }
    .condensed-upload-zone .filename-container {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        padding: 3px;
        width: 100%;
    }
    .condensed-upload-zone .filename-container span { 
        margin-bottom: 3px; font-size: 0.9em; 
        word-wrap: break-word; word-break: break-word;
        width: 100%;
    }


    .btn-base {
        background-color: var(--primary-bg);
        color: var(--primary-text);
        border: 1px solid var(--primary-text);
        cursor: pointer;
        transition: background-color 0.2s;
        font-family: inherit;
        display: inline-flex;
        align-items: center;
    }
    .btn-base:hover {
        background-color: var(--hover-grey);
        transform: translateY(-1px);
    }
    .btn-base:disabled {
        color: var(--muted-grey);
        border-color: var(--muted-grey);
        cursor: not-allowed;
        background-color: var(--dark-grey);
    }

    .change-image-button {
        padding: 4px 7px;
        justify-content: center;
        font-size: 0.8em;
        align-self: flex-start;
        margin-top: 5px;
        width: 100%;
        max-width: 140px;
    }
    .download-button {
        width: 100%;
    }
    .download-buttons-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
        width: 100%;
    }
    .reset-button-container {
        width: 100%; margin-top: 10px; display: flex; justify-content: flex-start;
    }
    .reset-button {
        background-color: var(--disabled-red);
        color: var(--error-text);
        border: 1px solid var(--error-text);
        padding: 6px 10px;
        width: auto;
        min-width: 160px;
        cursor: pointer;
        transition: background-color 0.2s;
    }
    .reset-button:hover { background-color: var(--hover-red); }


    .mobile-panel {
        display: none; width: 100%; flex-direction: column; align-items: center;
        padding: 10px; box-sizing: border-box; background-color: var(--primary-bg);
    }
    #mobileUploadPanelPlaceholder { align-items: center; }
    #mobileDownloadPanelPlaceholder { border-top: 1px solid var(--border-primary); align-items: flex-start; }
    #mobileSettingsPanel { border-bottom: 1px solid var(--border-primary); border-top: 1px solid var(--border-primary); }


    .info-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--overlay-bg);
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
        box-sizing: border-box;
    }

    .info-modal-content {
        background-color: var(--primary-bg);
        border: 2px solid var(--primary-text);
        max-width: 600px;
        max-height: 80vh;
        width: 100%;
        overflow-y: auto;
        color: var(--primary-text);
        font-family: "Courier New", Courier, monospace;
    }

    .info-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px 25px 10px 25px;
        border-bottom: 1px solid var(--border-primary);
    }

    .info-modal-header h2 {
        margin: 0;
        color: var(--primary-text);
        font-size: 1.5em;
    }

    .info-modal-close {
        background: none;
        border: none;
        color: var(--primary-text);
        font-size: 2em;
        cursor: pointer;
        padding: 0;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .info-modal-close:hover {
        color: var(--error-text);
    }

    .info-modal-body {
        padding: 0px 25px 25px 25px;
        line-height: 1.4;
    }

    .info-modal-body h3 {
        color: var(--primary-text);
        margin: 20px 0 0 0;
        font-size: 1.2em;
    }

    .info-modal-body ul, .info-modal-body ol {
        margin: 10px 0;
        padding-left: 25px;
    }

    .info-modal-body p {
        margin: 15px 0;
    }

    .info-modal-body strong {
        color: var(--primary-text);
        font-weight: bold;
    }

    .info-modal-footer {
        padding-top: 20px;
        border-top: 1px solid var(--border-primary);
        display: flex;
        justify-content: center;
    }

    .btn-action {
        padding: 6px 10px;
        font-size: 0.85em;
        justify-content: flex-start;
        padding-left: 10px;
        margin-bottom: 0;
    }
    .btn-action i { 
        margin-right: 8px; 
        font-size: 1.1em; 
    }

    .fps-options-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
        margin: 20px 0px 20px 0px;
    }

    .fps-option-button {
        background-color: var(--primary-bg);
        color: var(--primary-text);
        border: 2px solid var(--border-primary);
        padding: 12px 15px;
        cursor: pointer;
        font-family: inherit;
        text-align: left;
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        justify-content: flex-start;
        min-height: 60px;
    }

    .fps-option-button:hover {
        background-color: var(--hover-grey);
        border-color: var(--primary-text);
        transform: translateY(-1px);
    }

    .fps-number {
        font-size: 1.3em;
        font-weight: bold;
        margin-bottom: 8px;
        color: var(--primary-text);
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .fps-description {
        align-self: flex-end;
    }

    .video-metadata {
        background-color: var(--accent-dark);
        border: 1px solid var(--border-primary);
        padding: 5px 15px 5px 15px;
        font-family: inherit;
    }

    .video-metadata h3 {
        margin: 0 0 10px 0;
        color: var(--primary-text);
        font-size: 1.1em;
    }

    .metadata-grid {
        display: flex;
        flex-direction: column;
        gap: 8px;
        font-size: 0.9em;
    }

    .metadata-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 4px 0;
    }

    .metadata-label {
        color: var(--muted-grey);
        font-weight: normal;
    }

    .metadata-value {
        color: var(--primary-text);
        font-weight: bold;
        text-align: right;
    }

    .glyphtrix-logo {
        font-family: "Courier New", Courier, monospace;
        font-weight: bold;
        font-size: 1.2em;
        color: var(--primary-text);
        text-align: center;
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        letter-spacing: 0.1em;
        opacity: 0.8;
        cursor: pointer;
        transition: opacity 0.3s ease;
        user-select: none;
    }

    .glyphtrix-logo:hover {
        opacity: 1;
    }

    .glyphtrix-logo.scrambling {
        animation: scramble 0.6s ease-in-out;
    }

    @keyframes scramble {
        0%, 100% { opacity: 0.8; }
        25% { opacity: 1; }
        50% { opacity: 0.9; }
        75% { opacity: 1; }
    }

    @media (min-width: 769px) and (max-width: 1600px) {
      body {
        flex-direction: row;
      }
      
      .container {
        flex-direction: column;
        margin-left: 400px;
        width: calc(100% - 400px);
        height: 100vh;
        display: flex;
      }
      
      .input-column, .output-column {
        width: 100%;
        height: 50vh;
        border-right: none;
        border-bottom: 1px solid var(--border-primary);
        display: flex;
        flex-direction: column;
      }
      
      .output-column {
        border-bottom: none;
      }
      
      .column-header {
        height: 75px;
        min-height: 75px;
        flex-shrink: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .input-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
        height: calc(100% - 75px);
      }
      
      .imageCanvas, #inputVideo, #outputCanvas {
        flex: 1;
        min-height: 200px;
        max-height: none;
      }
      
      .settings-panel-container {
        position: fixed;
        left: 0;
        top: 0;
        width: 400px;
        height: 100vh;
        flex-direction: column;
        overflow-y: auto;
        border-right: 2px solid var(--border-primary);
        z-index: 100;
        background-color: var(--primary-bg);
      }
      
      .settings-panel-section-content {
        flex: none;
        min-height: auto;
        border-right: none;
        border-left: none;
        border-bottom: 1px solid var(--border-primary);
        padding: 15px;
      }
      

      
      .upload-panel-content,
      .download-panel-content {
        border-right: none;
        border-left: none;
      }


      .glyphtrix-logo {
        position: static;
        transform: none;
        text-align: center;
        align-self: center;
        width: 100%;
      }
      
      .image-settings-layout,
      .font-settings-layout,
      .output-settings-layout {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
      }
      
      .settings-column {
        margin-bottom: 0;
      }
      
      .mobile-panel {
        display: none;
      }
      
      .mobile-preview-panel,
      .sticky-spacer {
        display: none !important;
      }
    }

    @media (max-width: 768px) {
      html, body { 
          height: auto;
          overflow-x: hidden;
          overflow-y: auto;
      }
      body { 
          justify-content: flex-start; 
      }
      .container { 
          flex-direction: column; 
          height: auto !important;
          min-height: auto;
      }
      .settings-panel-container { display: none !important; }
      .mobile-panel { display: flex; }
      .mobile-panel .settings-panel-section-content h2 { display: block; text-align: left; }
      .upload-panel-content, .download-panel-content { border-right: none !important; border-left: none !important; }
      .settings-panel-section-content > .control-group,
      .settings-panel-section-content > .condensed-upload-zone,
      .settings-panel-section-content > .download-buttons-grid,
      .settings-panel-section-content > .image-settings-layout,
      .settings-panel-section-content > .output-settings-layout,
      .settings-panel-section-content > .font-settings-layout,
      .settings-panel-section-content > .checkbox-container {
          margin-left: 0; width: 100%;
      }
      .image-settings-layout, .output-settings-layout, .font-settings-layout { flex-direction: column; gap: 0; }
      .settings-column { margin-bottom: 10px; width: 100%;}

      /* Hide preview toggle on mobile */
      #previewChangesContainer {
          display: none !important;
      }

      .column-header { height: 50px; border-top: 1px solid var(--border-primary); }
      .input-column, .output-column { 
          width: 100%; 
          height: auto;
          border-right: none; 
          display: flex;
          flex-direction: column;
      }
      .input-area { 
          display: flex; 
          padding: 10px;
          box-sizing: border-box;
          height: auto;
          overflow: visible;
          flex-grow: 0;
          min-height: 0;
          justify-content: flex-start;
          align-items: flex-start;
      }
      #outputCanvas { 
          width: 100%; 
          height: auto;
          max-width: 100%;
          object-fit: contain;
          flex-grow: 0;
          min-height: 0;
          transition: all 0.3s ease;
      }
      

      .mobile-preview-panel {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 400px;
          z-index: 50;
          background-color: var(--primary-bg);
          display: none;
      }
      
      .mobile-preview-panel.active {
          display: flex;
          flex-direction: column;
      }
      
      .mobile-preview-header {
          height: 50px;
          display: flex;
          align-items: center;
          justify-content: center;
          border-bottom: 1px solid var(--border-primary);
          background-color: var(--primary-bg);
          position: relative;
      }
      
      .mobile-preview-toggle {
          display: flex;
          gap: 30px;
          align-items: center;
      }
      
      .mobile-toggle-option {
          font-size: 1.1em;
          font-weight: bold;
          cursor: pointer;
          padding: 8px 12px;
          transition: all 0.3s ease;
          color: var(--muted-grey);
          text-decoration: none;
          border-bottom: 2px solid transparent;
      }
      
      .mobile-toggle-option.active {
          color: var(--primary-text);
          border-bottom-color: var(--primary-text);
      }
      
      .mobile-toggle-option:hover {
          color: var(--primary-text);
      }
      
      .mobile-preview-content {
          flex: 1;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          position: relative;
          border-bottom: 1px solid var(--border-primary);
      }
      
      .mobile-preview-content canvas,
      .mobile-preview-content video,
      .mobile-preview-content .upload-zone {
          max-width: 100%;
          max-height: 350px;
          object-fit: contain;
      }
      
      .mobile-preview-content .upload-zone {
          width: 80%;
          height: 200px;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          border: 4px dashed var(--border-primary);
          cursor: pointer;
          transition: background-color 0.2s;
      }
      
      .mobile-preview-content .upload-zone:hover {
          background-color: var(--hover-grey);
      }
      

      .sticky-spacer {
          height: 400px;
          display: none;
      }
      
      .sticky-spacer.active {
          display: block;
          flex-shrink: 0;
      }
      

      .imageCanvas, #inputVideo {
          width: 100%;
          height: auto;
          max-width: 100%;
          object-fit: contain;
          flex-grow: 0;
          min-height: 0;
      }
      .settings-panel-section-content {
            margin-bottom: 10px; width: 100%; padding: 0 5px; overflow-y: visible; align-items: flex-start;
      }
      .settings-image-content .slider-container,
      .settings-image-content .checkbox-container,
      .settings-font-content .control-container,
      .settings-output-content .control-container { align-items: center; }
      .upload-panel-content, .download-panel-content { align-items: flex-start; }


      .glyphtrix-logo {
        position: static;
        transform: none;
        margin-bottom: 10px;
        padding-bottom: 10px;
        font-size: 1.1em;
        text-align: center;
        align-self: center;
        width: 100%;
      }
      .download-buttons-grid { grid-template-columns: 1fr; }
      .change-image-button, .download-button, .reset-button { width: 100%; max-width: none; margin-bottom: 5px; box-sizing: border-box;}
      

      .condensed-upload-zone {
        width: 100%;
        max-width: none;
        display: block;
        min-height: auto;
        padding: 10px;
      }
      
      .condensed-upload-zone label {
        display: flex;
        flex-direction: column;
        width: 100%;
        min-height: auto;
      }
      
      .condensed-upload-zone .filename-container {
        width: 100%;
        display: flex;
        flex-direction: column;
        min-height: auto;
      }
      
      .condensed-upload-zone .filename-container span {
        white-space: normal;
        line-height: 1.3;
        margin-bottom: 8px;
        display: block;
        width: 100%;
      }
      
      .upload-panel-content {
        padding: 10px !important;
        width: 100%;
        overflow: visible;
      }
      

      .slider-container, .control-container, .checkbox-container, .reset-button-container {
        max-width: none;
        width: 100%;
        margin-bottom: 25px;
      }
      
      .control-container select, .select-group select {
        max-width: none;
        width: 100%;
      }
      
      .input-group, .select-group {
        max-width: none;
        width: 100%;
      }
      
      .slider-container input[type="range"], .input-group input[type="number"], .select-group select {
          width: 100%;
          max-width: none;
      }


      .info-modal {
          padding: 10px;
      }
      .info-modal-content {
          max-height: 90vh;
      }
      .info-modal-header, .info-modal-body {
          padding: 15px 20px;
      }
    }

    @media (max-width: 2000px) {
      .font-settings-layout, .output-settings-layout {
        flex-direction: column !important;
        gap: 0 !important;
      }
      .font-settings-layout .settings-column, .output-settings-layout .settings-column {
        margin-bottom: 10px;
        width: 100%;
      }
      .settings-panel-container {
        min-height: 280px;
      }
    }



    @media (max-height: 800px) and (min-width: 1601px) {
      .imageCanvas, #inputVideo {
        min-height: 300px !important;
        max-height: calc(100vh - 350px) !important;
      }
      #outputCanvas {
        min-height: 300px !important;
        max-height: calc(100vh - 350px) !important;
      }
      .settings-panel-container {
        min-height: 200px !important;
        max-height: 250px;
        overflow-y: auto;
      }
      .input-area {
        min-height: 250px;
      }
    }

    @media (min-width: 1601px) {
      .mobile-preview-panel,
      .sticky-spacer {
        display: none !important;
      }
    }
  </style>
</head>
<body>
  <!-- Mobile preview panel with toggle -->
  <div class="mobile-preview-panel" id="mobilePreviewPanel">
    <div class="mobile-preview-header">
      <div class="mobile-preview-toggle">
        <span class="mobile-toggle-option active" id="mobileInputToggle">Input</span>
        <span class="mobile-toggle-option" id="mobileOutputToggle">Output</span>
      </div>
      <span id="mobileLoadingSpinner" style="display: none;"></span>
    </div>
    <div class="mobile-preview-content" id="mobilePreviewContent">
      <!-- Content will be dynamically inserted here -->
    </div>
  </div>

  <!-- Sticky spacer for mobile preview panel -->
  <div class="sticky-spacer" id="mobilePreviewSpacer"></div>

  <div class="container" id="mainContainer">
    <div class="input-column" id="inputColumn">
      <div class="column-header">
        <h2>Input</h2>
      </div>
      <div class="input-area">
        <input type="file" id="imageUpload" accept="image/* video/*">
        <div class="upload-zone" id="uploadZone">
          <i class="ri-upload-2-fill" id="uploadIcon"></i>
          <div class="upload-spinner" id="uploadSpinner"></div>
          <span id="uploadText">
            Drag & drop an image/video here
            <br>
            <span style="color: var(--muted-grey);">or</span>
            <br>
            Click to upload
            <br>
            <span style="color: var(--muted-grey);">or</span>
            <br>
            Select an example from below
          </span>
        </div>
        <div class="example-buttons-container" id="exampleButtonsContainer">
          <button class="btn-base btn-action" onclick="loadExampleImage()">
            <i class="ri-image-line"></i> Load Example Image
          </button>
          <button class="btn-base btn-action" onclick="loadExampleVideo()">
            <i class="ri-video-line"></i> Load Example Video
          </button>
        </div>
        <canvas id="inputCanvas" class="imageCanvas"></canvas>
        <video id="inputVideo" class="imageCanvas" playsinline loop muted controls></video>
      </div>
    </div>

    <div class="output-column" id="outputColumn">
      <div class="column-header">
        <h2>Output</h2>
        <span id="loadingSpinner" style="display: none;"></span>
        <div id="sequenceLoadingMessage" style="display: none;"></div>
      </div>
      <canvas id="outputCanvas"></canvas>
      <div id="sequenceLoadingOverlay" style="display: none;">
        <div id="sequenceLoadingSpinner"></div>
        <p id="sequenceLoadingOverlayText">Rendering PNG Sequence...</p>
        <button id="cancelSequenceButton">Cancel Rendering</button>
      </div>
      <a id="downloadLink" style="display: none;" download="Glyphtrix_image.png">Download Image</a>
    </div>
  </div>

  <div class="mobile-panel" id="mobileUploadPanelPlaceholder"></div>
  <div class="mobile-panel" id="mobileSettingsPanel"></div>
  <div class="mobile-panel" id="mobileDownloadPanelPlaceholder"></div>

  <!-- Info Modal -->
  <div id="infoModal" class="info-modal" style="display: none;">
    <div class="info-modal-content">
      <div class="info-modal-header">
        <h2>About Glyphtrix</h2>
        <button class="info-modal-close" onclick="closeInfoModal()">&times;</button>
      </div>
      <div class="info-modal-body">
        <p><strong>Glyphtrix</strong> is a local web app that transforms images and videos into real-time, character-based visual art in your browser.</p>
        
        <h3>How to Use</h3>
        <ol>
          <li>Upload an image or video</li>
          <li>Adjust the settings to customize your character art</li>
          <li>Preview and download your creation</li>
        </ol>

        <h3>Tips</h3>
        <ul>
          <li>If output looks blurry, increase <u>Scale Factor</u> value</li>
          <li>Increasing <u>Density</u> value makes characters bigger</li>
          <li>Pay attention to <u>Resolution</u>, larger values will take longer to render</li>
        </ul>

        <h3>Features</h3>
        <ul>
          <li>Image & video support</li>
          <li>Multiple (customizable) character sets</li>
          <li>Customizable output</li>
          <li>Real-time processing</li>
          <li>Export as image, text or animated sequence</li>
        </ul>
           
        <h3>Privacy</h3>
        <ul>
          <li>No cloud processing, servers or installations</li>
          <li>Everything happens locally in your browser</li>
        </ul>

        <div class="info-modal-footer">
          <button class="btn-base btn-action" onclick="openGitHub()">
            <i class="ri-github-line"></i> View source code on GitHub
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- FPS Selection Modal -->
  <div id="fpsModal" class="info-modal" style="display: none;">
    <div class="info-modal-content">
      <div class="info-modal-header">
        <h2>Choose Sequence FPS</h2>
        <button class="info-modal-close" onclick="closeFpsModal()">&times;</button>
      </div>
      <div class="info-modal-body">
        <div class="fps-options-grid" id="fpsOptionsGrid">
        </div>
        <div class="video-metadata" id="videoMetadata"></div>
      </div>
    </div>
  </div>

  <div class="settings-panel-container" id="desktopSettingsPanel">
    <div class="settings-panel-section-content upload-panel-content" id="uploadPanelContent">
      <div class="glyphtrix-logo" id="glyphtrixLogo">GLYPHTRIX</div>
      <h2 id="uploadPanelTitle" class="initially-hidden">Upload</h2>
      <div class="condensed-upload-zone" id="condensedUploadZone" style="display: none;">
        <label for="condensedImageUpload">
            <div class="filename-container">
                <span id="condensedFilename"><i class="ri-check-line"></i> Select Image</span>
                <button class="btn-base change-image-button" onclick="document.getElementById('imageUpload').click()"><i class="ri-upload-2-fill"></i> New Upload</button>
            </div>
            <input type="file" id="condensedImageUpload" accept="image/* video/*">
        </label>
      </div>
    </div>
    <div class="settings-panel-section-content settings-title-section" id="settingsTitleSection">
        <h2>Settings for</h2>
    </div>
    <div class="settings-panel-section-content settings-image-content" id="imageSettingsContent">
      <h2>Image</h2>
      <div class="image-settings-layout">
            <div class="settings-column">
                <div class="checkbox-container control-group" id="previewChangesContainer">
                    <input type="checkbox" id="previewChangesToggle">
                    <label for="previewChangesToggle">Preview Changes</label>
                </div>
                <div class="checkbox-container control-group" id="invertColorsContainer">
                    <input type="checkbox" id="invertColorsToggle">
                    <label for="invertColorsToggle">Invert</label>
                </div>
                <div class="checkbox-container control-group" id="backgroundRemovalContainer">
                    <input type="checkbox" id="backgroundRemovalToggle">
                    <label for="backgroundRemovalToggle">Remove Chroma</label>
                </div>
            </div>
            <div class="settings-column">
                <div class="slider-container control-group">
                    <label for="levelsSlider">Grayscale Values <span id="levelsValueDisplay">4</span></label>
                    <input type="range" id="levelsSlider" min="2" max="16" value="4">
                </div>
                <div class="slider-container control-group">
                    <label for="brightnessSlider">Brightness <span id="brightnessValueDisplay">0</span></label>
                    <input type="range" id="brightnessSlider" min="-100" max="100" value="0">
                </div>
                <div class="slider-container control-group" id="contrastSliderContainer">
                    <label for="contrastSlider">Contrast <span id="contrastValueDisplay">0</span></label>
                    <input type="range" id="contrastSlider" min="-100" max="100" value="0">
                </div>
            </div>
            <div class="settings-column">
                <div class="slider-container control-group">
                    <label for="highlightInputSlider">Highlight <span id="highlightInputValueDisplay">255</span></label>
                    <input type="range" id="highlightInputSlider" min="0" max="255" value="255">
                </div>
                <div class="slider-container control-group">
                    <label for="midtoneGammaSlider">Midtone <span id="midtoneGammaValueDisplay">1.0</span></label>
                    <input type="range" id="midtoneGammaSlider" min="0.1" max="2" value="1" step="0.1">
                </div>
                 <div class="slider-container control-group">
                    <label for="shadowInputSlider">Shadow <span id="shadowInputValueDisplay">0</span></label>
                    <input type="range" id="shadowInputSlider" min="0" max="255" value="0">
                </div>
            </div>
        </div>
    </div>
    <div class="settings-panel-section-content settings-font-content" id="fontSettingsContent">
      <h2>Glyph</h2>
      <div class="font-settings-layout">
            <div class="settings-column">
                <div class="control-container control-group" style="margin-bottom: 0px;">
                    <label for="characterSetSelect">Character Set</label>
                    <div class="select-group">
                        <button class="btn-base" id="prevCharSetButton"><</button>
                        <select id="characterSetSelect">
                            <option value="binary">1. Binary (0,1)</option>
                            <option value="numbers">2. Numbers (0-9)</option>
                            <option value="latin_basic">3. Latin (Basic)</option>
                            <option value="latin">4. Latin (Extended)</option>
                            <option value="cyrillic">5. Cyrillic</option>
                            <option value="devanagari">6. Devanagari</option>
                            <option value="thai">7. Thai</option>
                            <option value="japanese">8. Japanese</option>
                            <option value="korean">9. Korean</option>
                            <option value="chinese">10. Chinese</option>
                            <option value="arabic">11. Arabic</option>
                            <option value="preset1">12. ABC</option>
                            <option value="preset2">13. A,B,C</option>
                            <option value="preset3">14. ⦁</option>
                            <option value="preset4">15. ●</option>
                            <option value="preset5">16. ⬤</option>
                            <option value="preset6">17. 〇</option>
                            <option value="preset7">18. ■</option>
                            <option value="preset8">19. █</option>
                            <option value="preset9">20. ▃</option>
                            <option value="preset10">21. ⯁</option>
                            <option value="preset11">22. ✖</option>
                            <option value="preset12">23. ✚</option>
                            <option value="preset13">24. ╋</option>
                            <option value="preset14">25. ⧸,⧹</option>
                            <option value="custom">26. Custom</option>
                        </select>
                        <button class="btn-base" id="nextCharSetButton">></button>
                    </div>
                </div>
                 <div class="control-container control-group" id="customCharsContainer" style="display: none;">
                    <div style="display: flex; align-items: center; gap: 2px;">
                        <input type="text" id="customCharsInput" placeholder="Chars or words, comma/dot separated" style="flex: 1;">
                        <button class="btn-base" id="customCharsHelpButton" style="font-size: 0.8em; border-radius: 3px; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center;">?</button>
                    </div>
                </div>
                <div class="control-container control-group">
                    <label for="fontSelect">Font Family</label>
                    <div class="select-group">
                        <button class="btn-base" id="prevFontButton"><</button>
                        <select id="fontSelect"></select>
                        <button class="btn-base" id="nextFontButton">></button>
                    </div>
                </div>
            </div>
            <div class="settings-column">
                <div class="control-container control-group"style="margin-bottom: 0px;">
                    <label for="colorSchemeSelect">Color Scheme</label>
                    <div class="select-group">
                        <button class="btn-base" id="prevColorSchemeButton"><</button>
                        <select id="colorSchemeSelect">
                            <option value="color1">Color 1</option>
                            <option value="color2">Color 2</option>
                            <option value="color3">Color 3</option>
                            <option value="custom">Color Custom</option>
                            <option value="gradient1">Gradient 1</option>
                            <option value="gradient2">Gradient 2</option>
                            <option value="gradient">Gradient Custom</option>
                        </select>
                        <button class="btn-base" id="nextColorSchemeButton">></button>
                    </div>
                </div>
                <div class="control-container control-group" id="gradientColorsContainer" style="display: none;">
                    <div style="display: flex; align-items: center; gap: 8px; margin-top: 5px;">
                        <input type="color" id="gradientTopColor" value="#FF6600" style="width: 40px; height: 28px; padding: 0; border: 1px solid var(--border-primary); background: none;">
                        <input type="color" id="gradientBottomColor" value="#0066FF" style="width: 40px; height: 28px; padding: 0; border: 1px solid var(--border-primary); background: none;">
                    </div>
                </div>
                <div class="control-container control-group" id="customColorsContainer" style="display: none;">
                    <div style="display: flex; align-items: center; gap: 8px; margin-top: 5px;">
                        <input type="color" id="customTextColor" value="#00FF00" style="width: 40px; height: 28px; padding: 0; border: 1px solid var(--border-primary); background: none;">
                        <input type="color" id="customBackgroundColor" value="#000000" style="width: 40px; height: 28px; padding: 0; border: 1px solid var(--border-primary); background: none;">
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="settings-panel-section-content settings-output-content" id="outputSettingsContent">
      <h2>Output</h2>
      <div class="output-settings-layout">
            <div class="settings-column">
                 <div class="control-container control-group">
                    <label for="densityInput">Density</label>
                    <div class="input-group">
                        <button class="btn-base" id="densityDecrement"><</button>
                        <input type="number" id="densityInput" min="1" max="50" value="5">
                        <button class="btn-base" id="densityIncrement">></button>
                    </div>
                </div>
                <div class="control-container control-group">
                    <label>Grid Size:<br/><span id="gridSizeDisplay">-</span></label>
                </div>
            </div>
            <div class="settings-column">
                <div class="control-container control-group">
                    <label for="scaleFactorInput">Scale Factor</label>
                    <div class="input-group">
                        <button class="btn-base" id="scaleFactorDecrement"><</button>
                        <input type="number" id="scaleFactorInput" min="0.5" max="5" value="1" step="0.5">
                        <button class="btn-base" id="scaleFactorIncrement">></button>
                    </div>
                </div>
                <div class="control-container control-group">
                    <label>Resolution:<br/><span id="outputResolutionDisplay">-</span></label>
                </div>
            </div>
        </div>
    </div>
    <div class="settings-panel-section-content download-panel-content" id="downloadPanelContent">
      <h2>Export</h2>
      <div class="download-buttons-grid">
        <button class="btn-base btn-action download-button" onclick="openNewTab()" id="openNewTabButton">
            <i class="ri-external-link-line"></i> Open Image
        </button>
         <button class="btn-base btn-action download-button" onclick="downloadPng()" id="downloadPngButton">
            <i class="ri-download-2-line"></i> Download Image
        </button>
        <button class="btn-base btn-action download-button" onclick="downloadText()" id="downloadTextButton">
            <i class="ri-download-2-line"></i> Download Text
        </button>
        <button class="btn-base btn-action download-button" onclick="openFpsModal()" id="downloadPngSequenceButton" style="display: none;">
            <i class="ri-download-2-line"></i> Download Sequence
        </button>
        <button class="btn-base btn-action download-button" onclick="openInfoModal()" id="openInfoButton">
            <i class="ri-information-line"></i> About Glyphtrix
        </button>
      </div>
    </div>
  </div>

  <script>
    // Global spinner function
    function getSpinner(size = 24) {
        return `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 24 24"><g><rect width="2" height="5" x="11" y="1" fill="currentColor" opacity=".14"/><rect width="2" height="5" x="11" y="1" fill="currentColor" opacity=".29" transform="rotate(30 12 12)"/><rect width="2" height="5" x="11" y="1" fill="currentColor" opacity=".43" transform="rotate(60 12 12)"/><rect width="2" height="5" x="11" y="1" fill="currentColor" opacity=".57" transform="rotate(90 12 12)"/><rect width="2" height="5" x="11" y="1" fill="currentColor" opacity=".71" transform="rotate(120 12 12)"/><rect width="2" height="5" x="11" y="1" fill="currentColor" opacity=".86" transform="rotate(150 12 12)"/><rect width="2" height="5" x="11" y="1" fill="currentColor" transform="rotate(180 12 12)"/><animateTransform attributeName="transform" calcMode="discrete" dur="0.75s" repeatCount="indefinite" type="rotate" values="0 12 12;30 12 12;60 12 12;90 12 12;120 12 12;150 12 12;180 12 12;210 12 12;240 12 12;270 12 12;300 12 12;330 12 12;360 12 12"/></g></svg>`;
    }

    const imageUpload = document.getElementById('imageUpload');
    const condensedImageUpload = document.getElementById('condensedImageUpload');
    const inputCanvas = document.getElementById('inputCanvas');
    const inputVideo = document.getElementById('inputVideo');
    const outputCanvas = document.getElementById('outputCanvas');
    const inputCtx = inputCanvas.getContext('2d');
    const outputCtx = outputCanvas.getContext('2d');
    const loadingSpinner = document.getElementById('loadingSpinner');
    const mobileLoadingSpinner = document.getElementById('mobileLoadingSpinner');
    const sequenceLoadingOverlay = document.getElementById('sequenceLoadingOverlay');
    const sequenceLoadingOverlayText = document.getElementById('sequenceLoadingOverlayText');
    const sequenceLoadingMessage = document.getElementById('sequenceLoadingMessage');
    const cancelSequenceButton = document.getElementById('cancelSequenceButton');


    const condensedUploadZone = document.getElementById('condensedUploadZone');
    const condensedFilename = document.getElementById('condensedFilename');
    const uploadPanelTitle = document.getElementById('uploadPanelTitle');

    const levelsSlider = document.getElementById('levelsSlider');
    const levelsValueDisplay = document.getElementById('levelsValueDisplay');
    const brightnessSlider = document.getElementById('brightnessSlider');
    const brightnessValueDisplay = document.getElementById('brightnessValueDisplay');
    const shadowInputSlider = document.getElementById('shadowInputSlider');
    const shadowInputValueDisplay = document.getElementById('shadowInputValueDisplay');
    const midtoneGammaSlider = document.getElementById('midtoneGammaSlider');
    const midtoneGammaValueDisplay = document.getElementById('midtoneGammaValueDisplay');
    const highlightInputSlider = document.getElementById('highlightInputSlider');
    const highlightInputValueDisplay = document.getElementById('highlightInputValueDisplay');
    const previewChangesToggle = document.getElementById('previewChangesToggle');
    const invertColorsToggle = document.getElementById('invertColorsToggle');
    const contrastSlider = document.getElementById('contrastSlider');
    const contrastSliderContainer = document.getElementById('contrastSliderContainer');
    const contrastValueDisplay = document.getElementById('contrastValueDisplay');
    const chromaRemovalToggle = document.getElementById('backgroundRemovalToggle');
    const chromaRemovalContainer = document.getElementById('backgroundRemovalContainer');
    const invertColorsContainer = document.getElementById('invertColorsContainer');
    const previewChangesContainer = document.getElementById('previewChangesContainer');


    const densityInput = document.getElementById('densityInput');
    const densityDecrement = document.getElementById('densityDecrement');
    const densityIncrement = document.getElementById('densityIncrement');
    const gridSizeDisplay = document.getElementById('gridSizeDisplay');
    const fontSelect = document.getElementById('fontSelect');
    const prevFontButton = document.getElementById('prevFontButton');
    const nextFontButton = document.getElementById('nextFontButton');
    const characterSetSelect = document.getElementById('characterSetSelect');
    const prevCharSetButton = document.getElementById('prevCharSetButton');
    const nextCharSetButton = document.getElementById('nextCharSetButton');
    const customCharsContainer = document.getElementById('customCharsContainer');
    const customCharsInput = document.getElementById('customCharsInput');
    const customCharsHelpButton = document.getElementById('customCharsHelpButton');


    const scaleFactorInput = document.getElementById('scaleFactorInput');
    const scaleFactorDecrement = document.getElementById('scaleFactorDecrement');
    const scaleFactorIncrement = document.getElementById('scaleFactorIncrement');
    const outputResolutionDisplay = document.getElementById('outputResolutionDisplay');
    const colorSchemeSelect = document.getElementById('colorSchemeSelect');
    const prevColorSchemeButton = document.getElementById('prevColorSchemeButton');
    const nextColorSchemeButton = document.getElementById('nextColorSchemeButton');
    const gradientColorsContainer = document.getElementById('gradientColorsContainer');
    const gradientTopColor = document.getElementById('gradientTopColor');
    const gradientBottomColor = document.getElementById('gradientBottomColor');
    const customColorsContainer = document.getElementById('customColorsContainer');
    const customTextColor = document.getElementById('customTextColor');
    const customBackgroundColor = document.getElementById('customBackgroundColor');


    const openNewTabButton = document.getElementById('openNewTabButton');
    const downloadPngButton = document.getElementById('downloadPngButton');
    const downloadTextButton = document.getElementById('downloadTextButton');
    const downloadPngSequenceButton = document.getElementById('downloadPngSequenceButton');

    const mainContainer = document.getElementById('mainContainer');
    const desktopSettingsPanelContainer = document.getElementById('desktopSettingsPanel');
    const mobileSettingsPanel = document.getElementById('mobileSettingsPanel');
    const mobileUploadPanelPlaceholder = document.getElementById('mobileUploadPanelPlaceholder');
    const mobileDownloadPanelPlaceholder = document.getElementById('mobileDownloadPanelPlaceholder');

    const uploadPanelContent = document.getElementById('uploadPanelContent');
    const settingsTitleSection = document.getElementById('settingsTitleSection');
    const imageSettingsContent = document.getElementById('imageSettingsContent');
    const fontSettingsContent = document.getElementById('fontSettingsContent');
    const outputSettingsContent = document.getElementById('outputSettingsContent');
    const downloadPanelContent = document.getElementById('downloadPanelContent');


    let randomNumberMap = {};
    const numbersChars = "0123456789";
    const latinBasicChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    const latinChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõöøùúûüýþÿ";
    const cyrillicChars = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдеёжзийклмнопрстуфхцчшщъыьэюя";
    const devanagariChars = "अआइईउऊऋॠऌएऐओऔअंअःकखगघङचछजझञटठडढणतथदधनपफबभमयरलवशषसहक़ख़ग़ज़ड़ढ़फ़य़ऴक्षत्रज्ञािीुूेैोौंः्";
    const thaiChars = "กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะาำิีึืุูเแโใไๅๆ็่้๊๋์";
    const japaneseChars = "一あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをんアイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン日一国会人年大十二本中長出三同時政事自行社見月分議後前民生連五発間対上部東者党地合市業内相方法四定今回新場金員九入選立開手米力学問高代明実円関決子動京全目表戦経通外最言氏現理調体化田当八六約主題下首意法";
    const koreanChars = "의가은은이하고는에의한을은도를다지지와과는있사기대에고는도한수시나자일내하는로와는생것있적정면위자이에서들중로서나시로를만아지자에서어는국년시기다리리마게명야";
    const chineseChars = "一的是不了人在有我他这中大为上个国到说们时要就出会可也你对生能而子那得于着下自之年过发后作里用道行所然家种事成方多经么去法学如都同现当没动面起看定天分还进好小部其些主样理心她本前开但因只从想实日军者无力它与长把机十民第公此已工使情明性知全三又关点正业外将两高间由问很最重并物手应战向头文体政美相见被利什二等产或新己制身果加西斯月话合回特代内信表化老给世位次度门任常先海通教儿原东声提立及比员解水名真论处走义各入几口认条平系气题活尔更别打女变四神总何电数安少报才结反受目太量再感建务做接必场件计管期市直德资命山金指克许统区保至队形社便空决治展马科司五基眼书非则听白却界达光放强即像难且权思王象完设式色路记南品住告类求据程北边风规解";
    const arabicChars = "ابتثجحخدذرزسشصضطظعغفقكلمنهوي";
    let customCharSeqIndex = 0;

    let currentBlobMatrix = null;
    let currentMediaElement = null;
    let originalPixelData = null;

    let currentImageOriginalWidth = 0;
    let currentImageOriginalHeight = 0;
    let isPreviewChangesActive = false;
    let isInvertColorsActive = false;
    let isChromaRemovalActive = false;
    let currentBackgroundTolerance = 10;
    let isVideoInput = false;
    let videoProcessLoopId = null;

    let isSequenceRendering = false;
    let cancelSequenceRenderFlag = false;
    let cachedZipBlob = null;
    let sequenceSettingsSnapshot = null;


    const availableFonts = [
        { name: 'Courier New', cssName: '"Courier New", Courier, monospace' },
        { name: 'Cutive Mono', cssName: '"Cutive Mono", monospace' },
        { name: 'Source Code Pro', cssName: '"Source Code Pro", monospace' },
        { name: 'Victor Mono', cssName: '"Victor Mono", monospace' },
        { name: 'Workbench', cssName: '"Workbench", monospace' },
        { name: 'Doto', cssName: '"Doto", monospace' },
        { name: 'VT323', cssName: '"VT323", monospace' },
        { name: 'Bytesized', cssName: '"Bytesized", monospace' }
    ];
    let currentFontFamily;

    let currentNumLevels, currentBrightness, currentContrast, currentShadowInput,
        currentMidtoneGamma, currentHighlightInput, currentDensity,
        currentScaleFactor, currentColorScheme, currentCharacterSet;

    const FIXED_FONT_SIZE = 8;

    function getCurrentSettingsSnapshot(fps) {
        return JSON.stringify({
            levels: levelsSlider.value,
            brightness: brightnessSlider.value,
            contrast: contrastSlider.value,
            shadow: shadowInputSlider.value,
            midtone: midtoneGammaSlider.value,
            highlight: highlightInputSlider.value,
            density: densityInput.value,
            scale: scaleFactorInput.value,
            colorScheme: colorSchemeSelect.value,
            font: fontSelect.value,
            charSet: characterSetSelect.value,
            customChars: customCharsInput.value,
            invert: invertColorsToggle.checked,
            chromaRemoval: chromaRemovalToggle.checked,
            sequenceFps: fps,
            gradientTop: gradientTopColor.value,
            gradientBottom: gradientBottomColor.value,
            customText: customTextColor.value,
            customBackground: customBackgroundColor.value,
        });
    }

    function clearCachedSequence() {
        cachedZipBlob = null;
        sequenceSettingsSnapshot = null;
        customCharSeqIndex = 0;
        updatePngSequenceButtonState();
    }

    function updatePngSequenceButtonState() {
        if (!isVideoInput) {
            downloadPngSequenceButton.style.display = 'none';
            return;
        }
        downloadPngSequenceButton.style.display = 'inline-flex';
        downloadPngSequenceButton.innerHTML = '<i class="ri-download-2-line"></i> Download Sequence';
        downloadPngSequenceButton.disabled = isSequenceRendering;
    }

    function toggleSequenceRenderingUI(isRendering, message = "") {
        isSequenceRendering = isRendering;
        cancelSequenceRenderFlag = false;

        if (isRendering) {
            outputCanvas.style.display = 'none';
            sequenceLoadingOverlay.style.display = 'flex';
            sequenceLoadingOverlayText.textContent = message || "Rendering Sequence...";
            sequenceLoadingMessage.textContent = message || "Rendering Sequence...";
            sequenceLoadingMessage.style.display = 'block';
            cancelSequenceButton.style.display = 'block';
        } else {
            outputCanvas.style.display = 'block';
            sequenceLoadingOverlay.style.display = 'none';
            sequenceLoadingMessage.style.display = 'none';
            sequenceLoadingMessage.textContent = "";
            cancelSequenceButton.style.display = 'none';
        }

        const controlsToDisable = [
            imageUpload, condensedImageUpload,
            levelsSlider, brightnessSlider,
            shadowInputSlider, midtoneGammaSlider, highlightInputSlider,
            invertColorsToggle, previewChangesToggle,
            densityInput, densityDecrement, densityIncrement, fontSelect, prevFontButton, nextFontButton,
            characterSetSelect, prevCharSetButton, nextCharSetButton, customCharsInput,
            scaleFactorInput, scaleFactorDecrement, scaleFactorIncrement, colorSchemeSelect, prevColorSchemeButton, nextColorSchemeButton,
            openNewTabButton, downloadPngButton, downloadTextButton
        ];

        controlsToDisable.forEach(control => {
            if (control) control.disabled = isRendering;
        });


        updatePngSequenceButtonState();
    }

    cancelSequenceButton.addEventListener('click', () => {
        cancelSequenceRenderFlag = true;
        sequenceLoadingOverlayText.textContent = "Cancelling rendering...";
        sequenceLoadingMessage.textContent = "Cancelling rendering...";
    });


    async function generateGlyphtrixFrameBlob(videoTime, tempCanvas, tempCtx, offscreenRenderCanvas, offscreenRenderCtx) {
        return new Promise(async (resolve, reject) => {
            if (cancelSequenceRenderFlag) {
                return reject(new Error("Sequence rendering cancelled by user."));
            }
            inputVideo.currentTime = videoTime;

            const onSeeked = async () => {
                inputVideo.removeEventListener('seeked', onSeeked);
                inputVideo.removeEventListener('error', onError);
                if (cancelSequenceRenderFlag) {
                    return reject(new Error("Sequence rendering cancelled during seek."));
                }
                try {
                    tempCtx.drawImage(inputVideo, 0, 0, currentImageOriginalWidth, currentImageOriginalHeight);
                    let framePixelData = tempCtx.getImageData(0, 0, currentImageOriginalWidth, currentImageOriginalHeight).data;

                    if (chromaRemovalToggle.checked) {
                        framePixelData = removeChroma(framePixelData, currentImageOriginalWidth, currentImageOriginalHeight, 10);
                    }
                    
                    if (invertColorsToggle.checked) {
                        framePixelData = invertPixelData(framePixelData);
                    }

                    let processedData = applyContrast(new Uint8ClampedArray(framePixelData), currentImageOriginalWidth, currentImageOriginalHeight, parseInt(contrastSlider.value));
                    processedData = applyLevelsAndBrightness(processedData, currentImageOriginalWidth, currentImageOriginalHeight, parseInt(brightnessSlider.value), parseInt(shadowInputSlider.value), parseFloat(midtoneGammaSlider.value), parseInt(highlightInputSlider.value));

                    const frameGrayscaleLevels = generateGrayscaleLevels(parseInt(levelsSlider.value));
                    const frameBlobMatrix = generateBlobMatrix(processedData, currentImageOriginalWidth, currentImageOriginalHeight, frameGrayscaleLevels, parseInt(densityInput.value), colorSchemeSelect.value, characterSetSelect.value);

                    const baseCharSize = FIXED_FONT_SIZE;
                    const effectiveCharSize = baseCharSize * parseFloat(scaleFactorInput.value);
                    const charWidth = effectiveCharSize;
                    const charHeight = effectiveCharSize;

                    if (frameBlobMatrix.length === 0 || frameBlobMatrix[0].length === 0) {
                       return reject(new Error("Empty frame matrix generated"));
                    }
                    const numOutputRows = frameBlobMatrix.length;
                    const numOutputCols = frameBlobMatrix[0].length;
                    offscreenRenderCanvas.width = Math.max(1, numOutputCols * charWidth);
                    offscreenRenderCanvas.height = Math.max(1, numOutputRows * charHeight);
                    offscreenRenderCtx.fillStyle = getCanvasBackgroundColor(colorSchemeSelect.value);
                    offscreenRenderCtx.fillRect(0, 0, offscreenRenderCanvas.width, offscreenRenderCanvas.height);
                    offscreenRenderCtx.font = `${effectiveCharSize}px ${availableFonts[fontSelect.selectedIndex].cssName}`;
                    offscreenRenderCtx.textAlign = 'left';
                    offscreenRenderCtx.textBaseline = 'top';

                    let currentY = 0;
                    for (let y = 0; y < numOutputRows; y++) {
                        let currentX = 0;
                        for (let x = 0; x < numOutputCols; x++) {
                            if (frameBlobMatrix[y] && frameBlobMatrix[y][x]) {
                                offscreenRenderCtx.fillStyle = frameBlobMatrix[y][x].color;
                                offscreenRenderCtx.fillText(frameBlobMatrix[y][x].char, currentX, currentY);
                            }
                            currentX += charWidth;
                        }
                        currentY += charHeight;
                    }

                    offscreenRenderCanvas.toBlob(blob => {
                        if (blob) resolve(blob);
                        else reject(new Error("Failed to create blob from offscreen canvas"));
                    }, 'image/png');

                } catch (error) {
                    reject(error);
                }
            };

            const onError = (e) => {
                inputVideo.removeEventListener('seeked', onSeeked);
                inputVideo.removeEventListener('error', onError);
                reject(new Error("Video seeking error during sequence rendering."));
            };

            inputVideo.addEventListener('seeked', onSeeked, { once: true });
            inputVideo.addEventListener('error', onError, { once: true });
        });
    }


    async function downloadPngSequenceWithFps(fps) {
        if (!isVideoInput || inputVideo.readyState < inputVideo.HAVE_METADATA || isSequenceRendering) return;

        closeFpsModal();

        const currentSettings = getCurrentSettingsSnapshot(fps);
        if (cachedZipBlob && sequenceSettingsSnapshot === currentSettings) {
            const randomHash = generateRandomHash(8);
            const link = document.createElement('a');
            link.href = URL.createObjectURL(cachedZipBlob);
            link.download = `Glyphtrix_sequence_${randomHash}.zip`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
            return;
        }
        clearCachedSequence();

        const wasPaused = inputVideo.paused;
        if (!wasPaused) inputVideo.pause();

        toggleSequenceRenderingUI(true, "Initializing sequence rendering...");

        const pngBlobs = [];
        const videoDuration = inputVideo.duration;
        const selectedFps = fps;
        const frameInterval = 1 / selectedFps;
        const numFrames = Math.floor(videoDuration / frameInterval);

        const tempCaptureCanvas = document.createElement('canvas');
        tempCaptureCanvas.width = currentImageOriginalWidth;
        tempCaptureCanvas.height = currentImageOriginalHeight;
        const tempCaptureCtx = tempCaptureCanvas.getContext('2d');

        const offscreenRenderCanvas = document.createElement('canvas');
        const offscreenRenderCtx = offscreenRenderCanvas.getContext('2d');

        let renderingCancelled = false;
        try {
            for (let i = 0; i < numFrames; i++) {
                if (cancelSequenceRenderFlag) {
                    renderingCancelled = true;
                    sequenceLoadingOverlayText.textContent = "Rendering cancelled.";
                    sequenceLoadingMessage.textContent = "Rendering cancelled.";
                    await new Promise(r => setTimeout(r, 1500));
                    break;
                }
                const currentTime = i * frameInterval;
                const progressMessage = `Rendering frame ${i + 1} of ${numFrames} and creating a .zip archive...`;
                sequenceLoadingOverlayText.textContent = progressMessage;
                sequenceLoadingMessage.textContent = progressMessage;

                const blob = await generateGlyphtrixFrameBlob(currentTime, tempCaptureCanvas, tempCaptureCtx, offscreenRenderCanvas, offscreenRenderCtx);
                pngBlobs.push(blob);
            }

            if (!renderingCancelled && pngBlobs.length > 0) {
                sequenceLoadingOverlayText.textContent = "Zipping frames and creating .zip archive...";
                sequenceLoadingMessage.textContent = "Zipping frames and creating .zip archive...";
                const zip = new JSZip();
                pngBlobs.forEach((blob, index) => {
                    const frameNumber = (index + 1).toString().padStart(4, '0');
                    zip.file(`frame_${frameNumber}.png`, blob);
                });

                cachedZipBlob = await zip.generateAsync({ type: "blob" });
                sequenceSettingsSnapshot = currentSettings;

                const randomHash = generateRandomHash(8);
                const link = document.createElement('a');
                link.href = URL.createObjectURL(cachedZipBlob);
                link.download = `Glyphtrix_sequence_${randomHash}.zip`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
            } else if (!renderingCancelled && numFrames > 0) {
                alert("No frames were rendered for the sequence. This might be due to a very short video or an issue.");
            }

        } catch (error) {
            if (!error.message.toLowerCase().includes("cancel")) {
                console.error("Error during PNG sequence rendering: ", error);
                alert(`Error during PNG sequence rendering: ${error.message}`);
            }
        } finally {
            toggleSequenceRenderingUI(false);
            if (!wasPaused && inputVideo.readyState >= inputVideo.HAVE_ENOUGH_DATA && !renderingCancelled) {
 
            }
            updatePngSequenceButtonState();
        }
    }


    function processCurrentFrame() {
        if (!inputVideo || inputVideo.paused || inputVideo.ended || inputVideo.readyState < inputVideo.HAVE_CURRENT_DATA) {
            stopVideoProcessingLoop();
            return;
        }
        processImageWithCurrentSettings().then(() => {
                    if (isPreviewChangesActive) {
            updateInputCanvasPreview();
        }

        if (window.innerWidth <= 768 && mobilePreviewActive) {
            debouncedUpdateMobilePreview();
        }
            
            if (!inputVideo.paused && !inputVideo.ended) {
                videoProcessLoopId = requestAnimationFrame(processCurrentFrame);
            } else {
                stopVideoProcessingLoop();
            }
        }).catch(error => {
            console.error("Error processing video frame:", error);
            stopVideoProcessingLoop();
        });
    }

    function setDownloadButtonsState(disabled) {
        openNewTabButton.disabled = disabled;
        downloadPngButton.disabled = disabled;
        downloadTextButton.disabled = disabled;
    }

    function getFailsafeDensity(width) {
        if (width > 2500) {
            return 40;
        } else if (width >= 1000) {
            return 20;
        } else {
            return 10;
        }
    }

    function setDefaultValues(contentWidth = null) {
        levelsSlider.value = 4; levelsValueDisplay.textContent = '4';
        brightnessSlider.value = 0; brightnessValueDisplay.textContent = '0';
        contrastSlider.value = 0; contrastValueDisplay.textContent = '0';
        shadowInputSlider.value = 0; shadowInputValueDisplay.textContent = '0';
        midtoneGammaSlider.value = 1.0; midtoneGammaValueDisplay.textContent = '1.0';
        highlightInputSlider.value = 255; highlightInputValueDisplay.textContent = '255';
        chromaRemovalToggle.checked = false;
        invertColorsToggle.checked = false;
        previewChangesToggle.checked = true;

        showExampleButtons();

        // Set failsafe density based on content width
        const failsafeDensity = contentWidth ? getFailsafeDensity(contentWidth) : 10;
        densityInput.value = failsafeDensity;
        scaleFactorInput.value = 1.0;
        colorSchemeSelect.value = 'color1';
        fontSelect.selectedIndex = 0;
        characterSetSelect.value = 'binary';
        customCharsInput.value = '0,1';
        customCharsContainer.style.display = 'flex';
        customCharsInput.disabled = false;
        customCharsHelpButton.disabled = false;
        gradientTopColor.value = '#FF6600';
        gradientBottomColor.value = '#0066FF';
        gradientColorsContainer.style.display = 'none';
        customTextColor.value = '#00FF00';
        customBackgroundColor.value = '#000000';
        customColorsContainer.style.display = 'none';
        gridSizeDisplay.textContent = '-';

        isBackgroundRemovalActive = backgroundRemovalToggle.checked;
        currentBackgroundTolerance = 10;
        isInvertColorsActive = invertColorsToggle.checked;
        isPreviewChangesActive = previewChangesToggle.checked;
        isChromaRemovalActive = chromaRemovalToggle.checked;
        currentNumLevels = parseInt(levelsSlider.value);
        currentBrightness = parseInt(brightnessSlider.value);
        currentContrast = parseInt(contrastSlider.value);
        currentShadowInput = parseInt(shadowInputSlider.value);
        currentMidtoneGamma = parseFloat(midtoneGammaSlider.value);
        currentHighlightInput = parseInt(highlightInputSlider.value);
        currentDensity = parseInt(densityInput.value);
        currentScaleFactor = parseFloat(scaleFactorInput.value);
        currentColorScheme = colorSchemeSelect.value;
        currentFontFamily = availableFonts[fontSelect.selectedIndex].cssName;
        currentCharacterSet = characterSetSelect.value;

        setDownloadButtonsState(true);
        clearCachedSequence();
    }


    function generateGrayscaleLevels(numLevels) {
        if (numLevels < 2) return [0, 1];
        const levels = [];
        for (let i = 0; i < numLevels; i++) { levels.push(i / (numLevels - 1)); }
        return levels;
    }

    function getRandomCharacterForLevel(grayscaleValue, charSet) {
        let charsToUse;
        switch (charSet) {
            case 'numbers': charsToUse = numbersChars; break;
            case 'latin_basic': charsToUse = latinBasicChars; break;
            case 'latin': charsToUse = latinChars; break;
            case 'cyrillic': charsToUse = cyrillicChars; break;
            case 'devanagari': charsToUse = devanagariChars; break;
            case 'thai': charsToUse = thaiChars; break;
            case 'japanese': charsToUse = japaneseChars; break;
            case 'korean': charsToUse = koreanChars; break;
            case 'chinese': charsToUse = chineseChars; break;
            case 'arabic': charsToUse = arabicChars; break;
            default: return '?';
        }
        return charsToUse[Math.floor(Math.random() * charsToUse.length)];
    }


    function invertPixelData(sourceData) {
        const invertedData = new Uint8ClampedArray(sourceData.length);
        for (let i = 0; i < sourceData.length; i += 4) {
            invertedData[i] = 255 - sourceData[i];
            invertedData[i + 1] = 255 - sourceData[i + 1];
            invertedData[i + 2] = 255 - sourceData[i + 2];
            invertedData[i + 3] = sourceData[i + 3];
        }
        return invertedData;
    }

    function applyContrast(sourceData, width, height, contrastAmount) {
        if (contrastAmount === 0) return new Uint8ClampedArray(sourceData);
        const outputData = new Uint8ClampedArray(sourceData);
        const factor = (259 * (contrastAmount + 255)) / (255 * (259 - contrastAmount));
        
        for (let i = 0; i < outputData.length; i += 4) {
            for (let c = 0; c < 3; c++) {
                let val = factor * (outputData[i + c] - 128) + 128;
                outputData[i + c] = Math.max(0, Math.min(255, val));
            }
        }
        return outputData;
    }

    function removeChroma(sourceData, width, height, tolerance) {
        if (!sourceData) return new Uint8ClampedArray(sourceData);
        
        const outputData = new Uint8ClampedArray(sourceData);
        
        // Sample corner pixels to detect chroma key color
        const corners = [
            0,
            (width - 1) * 4,
            (height - 1) * width * 4,
            ((height - 1) * width + (width - 1)) * 4
        ];
        
        let chromaR = 0, chromaG = 0, chromaB = 0;
        let validCorners = 0;
        
        for (let corner of corners) {
            if (corner < sourceData.length - 3) {
                chromaR += sourceData[corner];
                chromaG += sourceData[corner + 1];
                chromaB += sourceData[corner + 2];
                validCorners++;
            }
        }
        
        if (validCorners === 0) return outputData;
        
        // Average chroma key color from corners
        chromaR = Math.round(chromaR / validCorners);
        chromaG = Math.round(chromaG / validCorners);
        chromaB = Math.round(chromaB / validCorners);
        
        const toleranceValue = tolerance * 2.55;
        
        for (let i = 0; i < outputData.length; i += 4) {
            const r = outputData[i];
            const g = outputData[i + 1];
            const b = outputData[i + 2];
            
            // Calculate color difference
            const diff = Math.sqrt(
                Math.pow(r - chromaR, 2) + 
                Math.pow(g - chromaG, 2) + 
                Math.pow(b - chromaB, 2)
            );
            
            // If pixel is similar to chroma key, make it black
            if (diff <= toleranceValue) {
                outputData[i] = 0;
                outputData[i + 1] = 0;
                outputData[i + 2] = 0;
            }
        }
        
        return outputData;
    }


    function applyLevelsAndBrightness(sourcePixelData, width, height, brightness, shadowIn, gamma, highlightIn) {
        const data = new Uint8ClampedArray(sourcePixelData);
        const bVal = (brightness / 100.0) * 127.5;
        const invGamma = 1.0 / gamma;
        const inputRange = Math.max(1, highlightIn - shadowIn);
        for (let i = 0; i < data.length; i += 4) {
            for (let c = 0; c < 3; c++) {
                let val = data[i + c] + bVal;
                if (val <= shadowIn) { val = 0; }
                else if (val >= highlightIn) { val = 255; }
                else { val = ((val - shadowIn) / inputRange) * 255; }
                val = 255 * Math.pow(val / 255, invGamma);
                data[i + c] = Math.max(0, Math.min(255, val));
            }
        }
        return data;
    }

    function getCharacterDisplayColor(level, scheme, rowIndex = 0, totalRows = 1) {
        const value = Math.round(level * 255);
        switch (scheme) {
                            case 'color1': return `rgb(0, ${value}, 0)`;
        case 'color2': return `rgb(${value}, ${value}, ${value})`;
        case 'color3': return `rgb(${255 - value}, ${255 - value}, ${255 - value})`;
            case 'gradient1': {
                const topColor = {r: 255, g: 102, b: 0};
                const bottomColor = {r: 0, g: 102, b: 255};
                
                const gradientPosition = totalRows > 1 ? rowIndex / (totalRows - 1) : 0;
                
                const r = Math.round(topColor.r + (bottomColor.r - topColor.r) * gradientPosition);
                const g = Math.round(topColor.g + (bottomColor.g - topColor.g) * gradientPosition);
                const b = Math.round(topColor.b + (bottomColor.b - topColor.b) * gradientPosition);
                
                const brightness = level;
                return `rgb(${Math.round(r * brightness)}, ${Math.round(g * brightness)}, ${Math.round(b * brightness)})`;
            }
            case 'gradient2': {
                const topColor = {r: 128, g: 0, b: 128};
                const bottomColor = {r: 0, g: 255, b: 255};
                
                const gradientPosition = totalRows > 1 ? rowIndex / (totalRows - 1) : 0;
                
                const r = Math.round(topColor.r + (bottomColor.r - topColor.r) * gradientPosition);
                const g = Math.round(topColor.g + (bottomColor.g - topColor.g) * gradientPosition);
                const b = Math.round(topColor.b + (bottomColor.b - topColor.b) * gradientPosition);
                
                const brightness = level;
                return `rgb(${Math.round(r * brightness)}, ${Math.round(g * brightness)}, ${Math.round(b * brightness)})`;
            }
            case 'gradient': {
                const topColor = hexToRgb(gradientTopColor.value);
                const bottomColor = hexToRgb(gradientBottomColor.value);
                
                const gradientPosition = totalRows > 1 ? rowIndex / (totalRows - 1) : 0;
                
                const r = Math.round(topColor.r + (bottomColor.r - topColor.r) * gradientPosition);
                const g = Math.round(topColor.g + (bottomColor.g - topColor.g) * gradientPosition);
                const b = Math.round(topColor.b + (bottomColor.b - topColor.b) * gradientPosition);
                
                const brightness = level;
                return `rgb(${Math.round(r * brightness)}, ${Math.round(g * brightness)}, ${Math.round(b * brightness)})`;
            }
            case 'custom': {
                const textColor = hexToRgb(customTextColor.value);
                
                const brightness = level;
                return `rgb(${Math.round(textColor.r * brightness)}, ${Math.round(textColor.g * brightness)}, ${Math.round(textColor.b * brightness)})`;
            }
            default: return `rgb(0, ${value}, 0)`;
        }
    }

    function hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : {r: 0, g: 255, b: 0};
    }
    function getCanvasBackgroundColor(scheme) {
        switch (scheme) {
            case 'color1': case 'color2': return getComputedStyle(document.documentElement).getPropertyValue('--primary-bg');
            case 'color3': return getComputedStyle(document.documentElement).getPropertyValue('--primary-white');
            case 'gradient1': case 'gradient2': case 'gradient': return getComputedStyle(document.documentElement).getPropertyValue('--primary-bg');
            case 'custom': return customBackgroundColor.value;
            default: return getComputedStyle(document.documentElement).getPropertyValue('--primary-bg');
        }
    }

    function drawPosterizedPreview(pixelDataToProcess, width, height, levelsArray) {
        inputCanvas.width = width;
        inputCanvas.height = height;
        const previewCtx = inputCanvas.getContext('2d');
        previewCtx.clearRect(0, 0, width, height);
        const outputImageData = previewCtx.createImageData(width, height);
        const outputData = outputImageData.data;
        for (let i = 0; i < pixelDataToProcess.length; i += 4) {
            const r = pixelDataToProcess[i], g = pixelDataToProcess[i + 1], b = pixelDataToProcess[i + 2], a = pixelDataToProcess[i + 3];
            const grayscale = (r + g + b) / 3;
            let closestLevelValue = levelsArray[0];
            let minDiff = Math.abs(grayscale - closestLevelValue * 255);
            for (let j = 1; j < levelsArray.length; j++) {
                const diff = Math.abs(grayscale - levelsArray[j] * 255);
                if (diff < minDiff) { minDiff = diff; closestLevelValue = levelsArray[j];}
            }
            const posterizedVal = Math.round(closestLevelValue * 255);
            outputData[i] = posterizedVal; outputData[i + 1] = posterizedVal; outputData[i + 2] = posterizedVal; outputData[i + 3] = a;
        }
        previewCtx.putImageData(outputImageData, 0, 0);
    }

    async function updateInputCanvasPreview() {
        if (!currentMediaElement || (isVideoInput && !currentMediaElement.videoWidth) || (!isVideoInput && !originalPixelData)) {
             inputCtx.clearRect(0, 0, inputCanvas.width, inputCanvas.height);
            return;
        }

        const isMobile = window.innerWidth <= 768;
        if (isMobile && isVideoInput) {
            inputVideo.style.display = 'block';
            inputCanvas.style.display = 'none';
            return;
        }

        if (isVideoInput) {
            if (isPreviewChangesActive && !isMobile) {
                inputVideo.style.display = 'none';
                inputCanvas.style.display = 'block';
                
                // Capture current video frame
                inputCanvas.width = currentImageOriginalWidth;
                inputCanvas.height = currentImageOriginalHeight;
                inputCtx.drawImage(inputVideo, 0, 0, currentImageOriginalWidth, currentImageOriginalHeight);
                
                let framePixelData = inputCtx.getImageData(0, 0, currentImageOriginalWidth, currentImageOriginalHeight).data;
                
                if (isChromaRemovalActive) {
                    framePixelData = removeChroma(framePixelData, currentImageOriginalWidth, currentImageOriginalHeight, currentBackgroundTolerance);
                }
                
                if (isInvertColorsActive) {
                    framePixelData = invertPixelData(framePixelData);
                }
                
                const tempContrast = parseInt(contrastSlider.value);
                const tempBrightness = parseInt(brightnessSlider.value);
                const tempShadow = parseInt(shadowInputSlider.value);
                const tempGamma = parseFloat(midtoneGammaSlider.value);
                const tempHighlight = parseInt(highlightInputSlider.value);
                const tempNumLevels = parseInt(levelsSlider.value);
                
                let processedForPreview = applyContrast(new Uint8ClampedArray(framePixelData), currentImageOriginalWidth, currentImageOriginalHeight, tempContrast);
                processedForPreview = applyLevelsAndBrightness(processedForPreview, currentImageOriginalWidth, currentImageOriginalHeight, tempBrightness, tempShadow, tempGamma, tempHighlight);
                
                const previewLevels = generateGrayscaleLevels(tempNumLevels);
                drawPosterizedPreview(processedForPreview, currentImageOriginalWidth, currentImageOriginalHeight, previewLevels);
            } else {
                inputVideo.style.display = 'block';
                inputCanvas.style.display = 'none';
            }
            return;
        }

        if(invertColorsContainer) invertColorsContainer.style.display = 'flex';
        if(previewChangesContainer) previewChangesContainer.style.display = 'flex';


        let dataForPreview = new Uint8ClampedArray(originalPixelData);
        
        if (isChromaRemovalActive) {
            dataForPreview = removeChroma(dataForPreview, currentImageOriginalWidth, currentImageOriginalHeight, currentBackgroundTolerance);
        }
        
        if (isInvertColorsActive) {
            dataForPreview = invertPixelData(dataForPreview);
        }

        if (isPreviewChangesActive && !isMobile) {
                    loadingSpinner.style.display = 'inline';
        if (mobileLoadingSpinner) mobileLoadingSpinner.style.display = 'inline';
        await new Promise(resolve => setTimeout(resolve, 0));
                    const tempContrast = parseInt(contrastSlider.value);
            const tempBrightness = parseInt(brightnessSlider.value);
            const tempShadow = parseInt(shadowInputSlider.value);
            const tempGamma = parseFloat(midtoneGammaSlider.value);
            const tempHighlight = parseInt(highlightInputSlider.value);
            const tempNumLevels = parseInt(levelsSlider.value);
            let processedForPreview = applyContrast(dataForPreview, currentImageOriginalWidth, currentImageOriginalHeight, tempContrast);
            processedForPreview = applyLevelsAndBrightness(processedForPreview, currentImageOriginalWidth, currentImageOriginalHeight, tempBrightness, tempShadow, tempGamma, tempHighlight);
        const previewLevels = generateGrayscaleLevels(tempNumLevels);
        drawPosterizedPreview(processedForPreview, currentImageOriginalWidth, currentImageOriginalHeight, previewLevels);
        loadingSpinner.style.display = 'none';
        if (mobileLoadingSpinner) mobileLoadingSpinner.style.display = 'none';
        } else {
             inputCanvas.width = currentImageOriginalWidth;
             inputCanvas.height = currentImageOriginalHeight;
             inputCtx.clearRect(0, 0, inputCanvas.width, inputCanvas.height);
             if (isInvertColorsActive) {
                const invertedOnly = invertPixelData(originalPixelData);
                const tempImgData = inputCtx.createImageData(currentImageOriginalWidth, currentImageOriginalHeight);
                tempImgData.data.set(invertedOnly);
                inputCtx.putImageData(tempImgData, 0, 0);
            } else {
                inputCtx.drawImage(currentMediaElement, 0, 0, currentImageOriginalWidth, currentImageOriginalHeight);
            }
        }
        
        if (currentMobileView === 'input') {
            debouncedUpdateMobilePreview();
        }
    }

    function generateBlobMatrix(pixelDataToProcess, originalWidth, originalHeight, levelsArray, densityStep, colorScheme, charSet) {
        let blobMatrix = [];
        
        // Calculate total number of rows for gradient calculation
        const totalRows = Math.ceil(originalHeight / densityStep);
        let currentRowIndex = 0;

        // Process from bottom to top to reverse the movement illusion
        for (let y = originalHeight - densityStep; y >= 0; y -= densityStep) {
            let blobRow = [];
            for (let x = 0; x < originalWidth; x += densityStep) {
                let avgR = 0, avgG = 0, avgB = 0, count = 0;
                for (let subY = 0; subY < densityStep && (y + subY) < originalHeight; subY++) {
                    for (let subX = 0; subX < densityStep && (x + subX) < originalWidth; subX++) {
                        const i = ((y + subY) * originalWidth + (x + subX)) * 4;
                        avgR += pixelDataToProcess[i]; avgG += pixelDataToProcess[i+1]; avgB += pixelDataToProcess[i+2]; count++;
                    }
                }
                if (count === 0) continue;
                avgR /= count; avgG /= count; avgB /= count;
                const grayscale = (avgR + avgG + avgB) / 3;
                let closestLevelValue = levelsArray[0];
                let minDiff = Math.abs(grayscale - closestLevelValue * 255);
                for (let j = 1; j < levelsArray.length; j++) {
                    const diff = Math.abs(grayscale - levelsArray[j] * 255);
                    if (diff < minDiff) { minDiff = diff; closestLevelValue = levelsArray[j]; }
                }
                let char = ' '; let color = getCharacterDisplayColor(0, colorScheme); let shouldDrawChar = false;
                if (colorScheme === 'blackOnWhite') {
                    shouldDrawChar = closestLevelValue < 1 || (levelsArray.length === 1 && levelsArray[0] === 1 && grayscale > 128);
                } else {
                    shouldDrawChar = closestLevelValue > 0 || (levelsArray.length === 1 && levelsArray[0] === 0 && grayscale < 128) || (levelsArray.length > 1 && closestLevelValue === 0);
                }

                if (shouldDrawChar) {
                    if (charSet === 'custom') {
                        const customText = customCharsInput.value.trim();
                        if (customText) {
                            if (customText.includes(',')) {
                                const customItems = customText.split(',').map(s => s.trim()).filter(s => s);
                                if (customItems.length > 0) {
                                    const selectedItem = customItems[Math.floor(Math.random() * customItems.length)];
                                    if (selectedItem.length > 1) {
                                        char = selectedItem[customCharSeqIndex % selectedItem.length];
                                        customCharSeqIndex++;
                                    } else {
                                        char = selectedItem;
                                    }
                                } else { char = '#'; }
                            } else if (customText.includes('.')) {
                                const customItems = customText.split('.').map(s => s.trim()).filter(s => s);
                                if (customItems.length > 0) {
                                    const flattenedChars = customItems.join('');
                                    char = flattenedChars[customCharSeqIndex % flattenedChars.length];
                                    customCharSeqIndex++;
                                } else { char = '#'; }
                            } else {
                                char = customText[customCharSeqIndex % customText.length];
                                customCharSeqIndex++;
                            }
                        } else { char = '#'; }
                    } else if (charSet.startsWith('preset') || charSet === 'binary') {
                        const presetValues = {
                             'binary': '0,1', 'preset1': 'ABC', 'preset2': 'A,B,C', 'preset3': '⦁', 'preset4': '●',
                             'preset5': '⬤', 'preset6': '〇', 'preset7': '■', 'preset8': '█', 'preset9': '▃',
                             'preset10': '⯁', 'preset11': '✖', 'preset12': '✚', 'preset13': '╋', 'preset14': '⧸,⧹'
                         };
                        const presetText = presetValues[charSet] || '#';
                        if (presetText.includes(',')) {
                            const presetItems = presetText.split(',').map(s => s.trim()).filter(s => s);
                            if (presetItems.length > 0) {
                                char = presetItems[Math.floor(Math.random() * presetItems.length)];
                            } else { char = '#'; }
                        } else {
                            char = presetText[customCharSeqIndex % presetText.length];
                            customCharSeqIndex++;
                        }
                    } else {
                        char = getRandomCharacterForLevel(closestLevelValue, charSet);
                    }
                    color = getCharacterDisplayColor(closestLevelValue, colorScheme, currentRowIndex, totalRows);
                }
                blobRow.push({char: char, color: color});
            }
            if (blobRow.length > 0) { 
                blobMatrix.unshift(blobRow);
                currentRowIndex++;
            }
        }
        return blobMatrix;
    }

    function drawTextOnCanvas(matrixToDraw, scaleFactor, colorScheme, fontFamily) {
        return new Promise((resolve) => {
            requestAnimationFrame(() => {
                const baseCharSize = FIXED_FONT_SIZE;
                const effectiveCharSize = baseCharSize * scaleFactor;
                const charWidth = effectiveCharSize; const charHeight = effectiveCharSize;
                if (matrixToDraw.length === 0 || matrixToDraw[0].length === 0) {
                    outputCanvas.width = 1; outputCanvas.height = 1; outputCtx.clearRect(0,0,1,1);
                    if (outputResolutionDisplay) outputResolutionDisplay.textContent = `${outputCanvas.width}x${outputCanvas.height}`;
                    if (gridSizeDisplay) gridSizeDisplay.textContent = `0x0`;
                    resolve(); return;
                }
                const numOutputRows = matrixToDraw.length; const numOutputCols = matrixToDraw[0].length;
                outputCanvas.width = Math.max(1, numOutputCols * charWidth);
                outputCanvas.height = Math.max(1, numOutputRows * charHeight);
                if (outputResolutionDisplay) outputResolutionDisplay.textContent = `${outputCanvas.width}x${outputCanvas.height}`;
                if (gridSizeDisplay) gridSizeDisplay.textContent = `${numOutputCols}x${numOutputRows}`;


                outputCtx.font = `${effectiveCharSize}px ${fontFamily}`;
                outputCtx.textAlign = 'left'; outputCtx.textBaseline = 'top';
                outputCtx.fillStyle = getCanvasBackgroundColor(colorScheme);
                outputCtx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);

                let currentY = 0;
                for (let y = 0; y < numOutputRows; y++) {
                    let currentX = 0;
                    for (let x = 0; x < numOutputCols; x++) {
                        if (matrixToDraw[y] && matrixToDraw[y][x]) {
                            outputCtx.fillStyle = matrixToDraw[y][x].color;
                            outputCtx.fillText(matrixToDraw[y][x].char, currentX, currentY);
                        }
                        currentX += charWidth;
                    }
                    currentY += charHeight;
                }
                resolve();
            });
        });
        
        forceUpdateMobileOutputCanvas();
    }
    function stopVideoProcessingLoop() {
        if (videoProcessLoopId !== null) {
            cancelAnimationFrame(videoProcessLoopId);
            videoProcessLoopId = null;
        }
    }


    async function processImageWithCurrentSettings() {
        if (isSequenceRendering) return;

        hideExampleButtons();

        loadingSpinner.style.display = 'inline';
        if (mobileLoadingSpinner) mobileLoadingSpinner.style.display = 'inline';
        if (!isVideoInput || inputVideo.paused) {
             setDownloadButtonsState(true);
        }

        isBackgroundRemovalActive = backgroundRemovalToggle.checked;
        currentBackgroundTolerance = 10;
        isInvertColorsActive = invertColorsToggle.checked;
        currentNumLevels = parseInt(levelsSlider.value);
        currentBrightness = parseInt(brightnessSlider.value);
        currentContrast = parseInt(contrastSlider.value);
        currentShadowInput = parseInt(shadowInputSlider.value);
        currentMidtoneGamma = parseFloat(midtoneGammaSlider.value);
        currentHighlightInput = parseInt(highlightInputSlider.value);
        currentDensity = parseInt(densityInput.value);
        currentScaleFactor = parseFloat(scaleFactorInput.value);
        currentColorScheme = colorSchemeSelect.value;
        currentFontFamily = availableFonts[fontSelect.selectedIndex].cssName;
        currentCharacterSet = characterSetSelect.value;

        await new Promise(resolve => setTimeout(resolve, 0));

        let sourcePixelData;
        if (isVideoInput) {
                    if (!currentMediaElement || currentMediaElement.readyState < inputVideo.HAVE_CURRENT_DATA ) {
            loadingSpinner.style.display = 'none';
            if (mobileLoadingSpinner) mobileLoadingSpinner.style.display = 'none';
            setDownloadButtonsState(true);
            return;
        }
            const tempVidCanvas = document.createElement('canvas');
            tempVidCanvas.width = currentImageOriginalWidth;
            tempVidCanvas.height = currentImageOriginalHeight;
            const tempVidCtx = tempVidCanvas.getContext('2d');
            tempVidCtx.drawImage(currentMediaElement, 0, 0, currentImageOriginalWidth, currentImageOriginalHeight);
            sourcePixelData = tempVidCtx.getImageData(0, 0, currentImageOriginalWidth, currentImageOriginalHeight).data;

            if (isChromaRemovalActive) {
                sourcePixelData = removeChroma(sourcePixelData, currentImageOriginalWidth, currentImageOriginalHeight, currentBackgroundTolerance);
            }
            if (isInvertColorsActive) {
                sourcePixelData = invertPixelData(sourcePixelData);
            }

        } else {
                    if (!originalPixelData) {
            loadingSpinner.style.display = 'none';
            if (mobileLoadingSpinner) mobileLoadingSpinner.style.display = 'none';
            setDownloadButtonsState(true);
            return;
        }
            sourcePixelData = new Uint8ClampedArray(originalPixelData);
            if (isChromaRemovalActive) {
                sourcePixelData = removeChroma(sourcePixelData, currentImageOriginalWidth, currentImageOriginalHeight, currentBackgroundTolerance);
            }
            if (isInvertColorsActive) {
                sourcePixelData = invertPixelData(sourcePixelData);
            }
        }

        let processedData = applyContrast(new Uint8ClampedArray(sourcePixelData), currentImageOriginalWidth, currentImageOriginalHeight, currentContrast);
        processedData = applyLevelsAndBrightness(processedData, currentImageOriginalWidth, currentImageOriginalHeight, currentBrightness, currentShadowInput, currentMidtoneGamma, currentHighlightInput);

        if (!isVideoInput && isPreviewChangesActive) {
            const previewLevels = generateGrayscaleLevels(currentNumLevels);
            let previewBaseData = new Uint8ClampedArray(originalPixelData);
            if (chromaRemovalToggle.checked) {
                previewBaseData = removeChroma(previewBaseData, currentImageOriginalWidth, currentImageOriginalHeight, 10);
            }
            if (invertColorsToggle.checked) {
                previewBaseData = invertPixelData(previewBaseData);
            }
                            let previewProcessed = applyContrast(previewBaseData, currentImageOriginalWidth, currentImageOriginalHeight, parseInt(contrastSlider.value));
                previewProcessed = applyLevelsAndBrightness(previewProcessed, currentImageOriginalWidth, currentImageOriginalHeight, parseInt(brightnessSlider.value), parseInt(shadowInputSlider.value), parseFloat(midtoneGammaSlider.value), parseInt(highlightInputSlider.value));
            drawPosterizedPreview(previewProcessed, currentImageOriginalWidth, currentImageOriginalHeight, previewLevels);

        } else if (isVideoInput && isPreviewChangesActive) {
            updateInputCanvasPreview();
        } else if (isVideoInput) {
             inputVideo.style.display = 'block';
             inputCanvas.style.display = 'none';
        }

        const localGrayscaleLevels = generateGrayscaleLevels(currentNumLevels);
        currentBlobMatrix = generateBlobMatrix(processedData, currentImageOriginalWidth, currentImageOriginalHeight, localGrayscaleLevels, currentDensity, currentColorScheme, currentCharacterSet);
        await drawTextOnCanvas(currentBlobMatrix, currentScaleFactor, currentColorScheme, currentFontFamily);

        loadingSpinner.style.display = 'none';
        if (mobileLoadingSpinner) mobileLoadingSpinner.style.display = 'none';
        setDownloadButtonsState(false);
        
        if (window.innerWidth <= 768 && mobilePreviewActive) {
            debouncedUpdateMobilePreview();
        }
    }


    function handleImageUpload(file) {
        stopVideoProcessingLoop();
        clearCachedSequence();
        isVideoInput = false;
        loadingSpinner.style.display = 'inline';
        if (mobileLoadingSpinner) mobileLoadingSpinner.style.display = 'inline';
        setDownloadButtonsState(true);
        downloadPngSequenceButton.style.display = 'none';

        // Show upload spinner
        showUploadSpinner();

        // Hide example buttons when file is loaded
        hideExampleButtons();

        inputVideo.style.display = 'none';
        inputVideo.pause();
        inputVideo.onloadedmetadata = null;
        inputVideo.onerror = null;
        inputVideo.onplay = null;
        inputVideo.onpause = null;
        inputVideo.onended = null;
        inputVideo.onseeked = null;
        inputVideo.src = "";
        inputCanvas.style.display = 'none';


        const reader = new FileReader();
        reader.onload = function(event) {
            if (file.type.startsWith('video/')) {
                isVideoInput = true;
                currentMediaElement = inputVideo;
                inputVideo.src = event.target.result;
                inputVideo.onloadedmetadata = async () => {
                    currentImageOriginalWidth = inputVideo.videoWidth;
                    currentImageOriginalHeight = inputVideo.videoHeight;
                    customCharSeqIndex = 0;
                    


                    inputVideo.style.display = 'block';
                    inputCanvas.style.display = 'none';

                    uploadZone.style.display = 'none';
                    if(uploadPanelTitle) uploadPanelTitle.style.display = 'block';
                    if(condensedUploadZone) condensedUploadZone.style.display = 'inline-block';
                    if(condensedFilename) condensedFilename.innerHTML = `<i class="ri-check-line"></i> ${file.name} `;
                    
                    // Ensure example buttons are hidden
                    hideExampleButtons();

                    if(previewChangesContainer) previewChangesContainer.style.display = 'flex';

                    setDefaultValues(inputVideo.videoWidth);
                    
                    // Override default preview settings for video
                    previewChangesToggle.checked = false;
                    isPreviewChangesActive = false;
                    previewChangesToggle.disabled = true;
                    currentDensity = parseInt(densityInput.value);




                    if(chromaRemovalContainer) chromaRemovalContainer.style.display = 'flex';
                    if(invertColorsContainer) invertColorsContainer.style.display = 'flex';


                    await processImageWithCurrentSettings();
                    loadingSpinner.style.display = 'none';
                    if (mobileLoadingSpinner) mobileLoadingSpinner.style.display = 'none';
                    hideUploadSpinner();
                    updatePngSequenceButtonState();
                    
                    previewChangesToggle.disabled = true;
                    
                    if (inputVideo.duration > 1) {
                        inputVideo.currentTime = 1;
                    }
                    
                    if (window.innerWidth <= 768 && mobilePreviewActive) {
                        switchMobileView('output');
                    } else {
                        debouncedUpdateMobilePreview();
                    }

                    inputVideo.onplay = () => {
                        clearCachedSequence();
                        stopVideoProcessingLoop();
                        if (previewChangesToggle.checked) {
                            previewChangesToggle.checked = false;
                            isPreviewChangesActive = false;
                            updateInputCanvasPreview();
                        }
                        previewChangesToggle.disabled = true;
                        videoProcessLoopId = requestAnimationFrame(processCurrentFrame);
                    };
                    inputVideo.onpause = () => {
                        previewChangesToggle.disabled = false;
                        processImageWithCurrentSettings();
                    };
                    inputVideo.onended = () => stopVideoProcessingLoop();
                    
                    let seekDebounceTimeout;
                    inputVideo.onseeked = () => {
                        clearTimeout(seekDebounceTimeout);
                        seekDebounceTimeout = setTimeout(() => {
                            if (inputVideo.paused && inputVideo.readyState >= inputVideo.HAVE_CURRENT_DATA) {
                                syncMobileVideoTime();
                                
                                processImageWithCurrentSettings().then(() => {
                                    if (window.innerWidth <= 768 && currentMobileView === 'output') {
                                        debouncedUpdateMobilePreview();
                                    }
                                });
                            }
                        }, 100);
                    };
                };
                 inputVideo.onerror = () => {
                    alert("Error loading video.");
                    loadingSpinner.style.display = 'none';
                    if (mobileLoadingSpinner) mobileLoadingSpinner.style.display = 'none';
                    hideUploadSpinner();
                    setDownloadButtonsState(true);
                    updatePngSequenceButtonState();
                };
            } else if (file.type.startsWith('image/')) {
                isVideoInput = false;
                const img = new Image();
                currentMediaElement = img;
                img.onload = async function() {
                    currentImageOriginalWidth = img.width;
                    currentImageOriginalHeight = img.height;
                    randomNumberMap = {};
                    customCharSeqIndex = 0;

                    inputCanvas.width = currentImageOriginalWidth;
                    inputCanvas.height = currentImageOriginalHeight;

                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = currentImageOriginalWidth;
                    tempCanvas.height = currentImageOriginalHeight;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(img, 0, 0, currentImageOriginalWidth, currentImageOriginalHeight);
                    originalPixelData = tempCtx.getImageData(0, 0, currentImageOriginalWidth, currentImageOriginalHeight).data;

                    if(chromaRemovalContainer) chromaRemovalContainer.style.display = 'flex';
                    if(invertColorsContainer) invertColorsContainer.style.display = 'flex';
                    if(previewChangesContainer) previewChangesContainer.style.display = 'flex';
                    
                    previewChangesToggle.disabled = false;

                    setDefaultValues(img.width);
                    currentDensity = parseInt(densityInput.value);





                    await processImageWithCurrentSettings();
                    await updateInputCanvasPreview();
                    inputCanvas.style.display = 'block';
                    uploadZone.style.display = 'none';
                    if(uploadPanelTitle) uploadPanelTitle.style.display = 'block';
                    
                    // Ensure example buttons are hidden
                    hideExampleButtons();
                    
                    hideUploadSpinner();
                    updatePngSequenceButtonState();
                    
                    if (window.innerWidth <= 768 && mobilePreviewActive) {
                        switchMobileView('output');
                    } else {
                        debouncedUpdateMobilePreview();
                    }
                }
                img.src = event.target.result;
                 img.onerror = () => {
                    alert("Error loading image.");
                    loadingSpinner.style.display = 'none';
                    if (mobileLoadingSpinner) mobileLoadingSpinner.style.display = 'none';
                    hideUploadSpinner();
                    setDownloadButtonsState(true);
                    updatePngSequenceButtonState();
                };
            } else {
                alert('Unsupported file type.');
                loadingSpinner.style.display = 'none';
                if (mobileLoadingSpinner) mobileLoadingSpinner.style.display = 'none';
                hideUploadSpinner();
                setDownloadButtonsState(true);
                updatePngSequenceButtonState();
            }
        }
        reader.readAsDataURL(file);
    }


    imageUpload.addEventListener('change', function(e) {
       if (e.target.files && e.target.files[0]) {
           handleImageUpload(e.target.files[0]);
           condensedUploadZone.style.display = 'inline-block';
           condensedFilename.innerHTML = `<i class="ri-check-line"></i> ${e.target.files[0].name} `;
           if(uploadPanelTitle) uploadPanelTitle.style.display = 'block';
       }
    });
    condensedImageUpload.addEventListener('change', (e) => {
        if (e.target.files && e.target.files[0]) {
            const file = e.target.files[0];
            handleImageUpload(file);
            condensedFilename.innerHTML = `<i class="ri-check-line"></i> ${file.name} `;
            if(uploadPanelTitle) uploadPanelTitle.style.display = 'block';
        }
    });

    function addSettingsChangeListener(element, eventType = 'input') {
        element.addEventListener(eventType, () => {
            clearCachedSequence();
            if (element === previewChangesToggle) {
                const isMobile = window.innerWidth <= 768;
                isPreviewChangesActive = !isMobile && element.checked;
                if (isVideoInput && element.checked && !inputVideo.paused && !isMobile) {
                    inputVideo.pause();
                }
                updateInputCanvasPreview();
            } else {
                if (element === contrastSlider) contrastValueDisplay.textContent = element.value;
                else if (element === levelsSlider) levelsValueDisplay.textContent = element.value;
                else if (element === brightnessSlider) brightnessValueDisplay.textContent = element.value;
                else if (element === shadowInputSlider) shadowInputValueDisplay.textContent = element.value;
                else if (element === midtoneGammaSlider) midtoneGammaValueDisplay.textContent = parseFloat(element.value).toFixed(1);
                else if (element === highlightInputSlider) highlightInputValueDisplay.textContent = element.value;
                                else if (element === characterSetSelect) {
                    customCharsContainer.style.display = 'flex';
                    
                    const isLanguage = ['numbers', 'latin_basic', 'latin', 'cyrillic', 'devanagari', 'thai', 'japanese', 'korean', 'chinese', 'arabic'].includes(element.value);
                    customCharsInput.disabled = isLanguage;
                    customCharsHelpButton.disabled = isLanguage;
                    
                    if (element.value === 'binary') {
                        customCharsInput.value = '0,1';
                    } else if (element.value === 'custom') {
                        customCharsInput.value = '';
                    } else if (element.value.startsWith('preset')) {
                        const presetValues = {
                             'preset1': 'ABC', 'preset2': 'A,B,C', 'preset3': '⦁', 'preset4': '●',
                             'preset5': '⬤', 'preset6': '〇', 'preset7': '■', 'preset8': '█', 'preset9': '▃',
                             'preset10': '⯁', 'preset11': '✖', 'preset12': '✚', 'preset13': '╋', 'preset14': '⧸,⧹'
                         };
                        customCharsInput.value = presetValues[element.value] || '';
                    } else if (isLanguage) {
                        customCharsInput.value = '';
                    }
                }
                else if (element === colorSchemeSelect) {
                    gradientColorsContainer.style.display = (element.value === 'gradient') ? 'block' : 'none';
                    customColorsContainer.style.display = (element.value === 'custom') ? 'block' : 'none';
                }
                else if (element === chromaRemovalToggle) {
                    isChromaRemovalActive = element.checked;
                }
                else if (element === invertColorsToggle) isInvertColorsActive = element.checked;

                processImageWithCurrentSettings();
                if (element !== previewChangesToggle) {
                     updateInputCanvasPreview();
                }
            }
        });
    }

    addSettingsChangeListener(previewChangesToggle, 'change');
    addSettingsChangeListener(chromaRemovalToggle, 'change');
    addSettingsChangeListener(invertColorsToggle, 'change');
    addSettingsChangeListener(contrastSlider);
    addSettingsChangeListener(levelsSlider);
    addSettingsChangeListener(brightnessSlider);
    addSettingsChangeListener(shadowInputSlider);
    addSettingsChangeListener(midtoneGammaSlider);
    addSettingsChangeListener(highlightInputSlider);
    addSettingsChangeListener(colorSchemeSelect, 'change');
    addSettingsChangeListener(fontSelect, 'change');
    addSettingsChangeListener(characterSetSelect, 'change');
        addSettingsChangeListener(customCharsInput, 'change');
    
    customCharsInput.addEventListener('input', () => {
        if (characterSetSelect.value !== 'custom') {
            characterSetSelect.value = 'custom';
        }
        clearCachedSequence();
    });
    
    addSettingsChangeListener(gradientTopColor, 'input');
    addSettingsChangeListener(gradientBottomColor, 'input');
    addSettingsChangeListener(customTextColor, 'input');
    addSettingsChangeListener(customBackgroundColor, 'input');

    // Help button functionality
    customCharsHelpButton.addEventListener('click', () => {
        alert('Custom Characters:\n\n• Using commas randomizes item output (e.g., "A,B,C")\n• Using dots flattens items into a sequence (e.g., "ABC.DEF" becomes "ABCDEF")\n• Supports all Unicode characters (for unique visual effects)');
    });




    function updateDensity(newValue) {
        clearCachedSequence();
        let val = parseInt(newValue); const min = parseInt(densityInput.min); const max = parseInt(densityInput.max);
        if (isNaN(val)) val = currentDensity; if (val < min) val = min; if (val > max) val = max;
        densityInput.value = val;
        if (val !== currentDensity) { currentDensity = val; processImageWithCurrentSettings(); }
        else { currentDensity = val; }
    }
    densityInput.addEventListener('change', function() { updateDensity(this.value); });
    densityDecrement.addEventListener('click', function() { updateDensity(parseInt(densityInput.value) - 1); });
    densityIncrement.addEventListener('click', function() { updateDensity(parseInt(densityInput.value) + 1); });

    prevFontButton.addEventListener('click', function() {
        clearCachedSequence();
        let currentIndex = fontSelect.selectedIndex;
        currentIndex = (currentIndex - 1 + availableFonts.length) % availableFonts.length;
        fontSelect.selectedIndex = currentIndex;
        processImageWithCurrentSettings();
    });
    nextFontButton.addEventListener('click', function() {
        clearCachedSequence();
        let currentIndex = fontSelect.selectedIndex;
        currentIndex = (currentIndex + 1) % availableFonts.length;
        fontSelect.selectedIndex = currentIndex;
        processImageWithCurrentSettings();
    });
    prevCharSetButton.addEventListener('click', function() {
        clearCachedSequence();
        let currentIndex = characterSetSelect.selectedIndex;
        currentIndex = (currentIndex - 1 + characterSetSelect.options.length) % characterSetSelect.options.length;
        characterSetSelect.selectedIndex = currentIndex;
        characterSetSelect.dispatchEvent(new Event('change'));
    });
    nextCharSetButton.addEventListener('click', function() {
        clearCachedSequence();
        let currentIndex = characterSetSelect.selectedIndex;
        currentIndex = (currentIndex + 1) % characterSetSelect.options.length;
        characterSetSelect.selectedIndex = currentIndex;
        characterSetSelect.dispatchEvent(new Event('change'));
    });


    function updateScaleFactor(newValue) {
        clearCachedSequence();
        let val = parseFloat(newValue); const min = parseFloat(scaleFactorInput.min); const max = parseFloat(scaleFactorInput.max);
        if (isNaN(val)) val = currentScaleFactor; if (val < min) val = min; if (val > max) val = max;
        scaleFactorInput.value = val.toFixed(1);
        if (val !== currentScaleFactor) { currentScaleFactor = val; processImageWithCurrentSettings(); }
        else { currentScaleFactor = val; }
    }
    scaleFactorInput.addEventListener('change', function() { updateScaleFactor(this.value); });
    scaleFactorDecrement.addEventListener('click', function() { updateScaleFactor(parseFloat(scaleFactorInput.value) - 0.5); });
    scaleFactorIncrement.addEventListener('click', function() { updateScaleFactor(parseFloat(scaleFactorInput.value) + 0.5); });

    prevColorSchemeButton.addEventListener('click', function() {
        clearCachedSequence();
        let currentIndex = colorSchemeSelect.selectedIndex;
        currentIndex = (currentIndex - 1 + colorSchemeSelect.options.length) % colorSchemeSelect.options.length;
        colorSchemeSelect.selectedIndex = currentIndex;
        gradientColorsContainer.style.display = (colorSchemeSelect.value === 'gradient') ? 'block' : 'none';
        customColorsContainer.style.display = (colorSchemeSelect.value === 'custom') ? 'block' : 'none';
        processImageWithCurrentSettings();
    });
    nextColorSchemeButton.addEventListener('click', function() {
        clearCachedSequence();
        let currentIndex = colorSchemeSelect.selectedIndex;
        currentIndex = (currentIndex + 1) % colorSchemeSelect.options.length;
        colorSchemeSelect.selectedIndex = currentIndex;
        gradientColorsContainer.style.display = (colorSchemeSelect.value === 'gradient') ? 'block' : 'none';
        customColorsContainer.style.display = (colorSchemeSelect.value === 'custom') ? 'block' : 'none';
        processImageWithCurrentSettings();
    });




    inputColumn.addEventListener('dragover', (e) => { e.preventDefault(); inputColumn.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--drag-hover'); });
    inputColumn.addEventListener('dragleave', () => { inputColumn.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--drag-default'); });
    inputColumn.addEventListener('drop', (e) => {
        e.preventDefault(); inputColumn.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--drag-default');
        const file = e.dataTransfer.files[0];
        if (file && (file.type.startsWith('image/') || file.type.startsWith('video/'))) {
          handleImageUpload(file);
          condensedUploadZone.style.display = 'inline-block';
          condensedFilename.innerHTML = `<i class="ri-check-line"></i> ${file.name} `;
           if(uploadPanelTitle) uploadPanelTitle.style.display = 'block';
        } else { alert('Please drop an image or video file.'); }
    });
    uploadZone.addEventListener('click', () => { imageUpload.click(); });

    inputCanvas.addEventListener('click', () => {
        const isMobile = window.innerWidth <= 768;
        if (!isMobile && isVideoInput && isPreviewChangesActive && inputCanvas.style.display !== 'none') {
            previewChangesToggle.checked = false;
            isPreviewChangesActive = false;
            updateInputCanvasPreview();
            
            if (inputVideo.paused) {
                inputVideo.play();
            }
        }
    });

    condensedUploadZone.addEventListener('dragover', (e) => { e.preventDefault(); condensedUploadZone.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--hover-grey'); });
    condensedUploadZone.addEventListener('dragleave', () => { condensedUploadZone.style.backgroundColor = 'transparent';});
    condensedUploadZone.addEventListener('drop', (e) => {
        e.preventDefault(); condensedUploadZone.style.backgroundColor = 'transparent';
        const file = e.dataTransfer.files[0];
        if (file && (file.type.startsWith('image/') || file.type.startsWith('video/'))) {
          handleImageUpload(file);
          condensedFilename.innerHTML = `<i class="ri-check-line"></i> ${file.name} `;
          if(uploadPanelTitle) uploadPanelTitle.style.display = 'block';
        } else { alert('Please drop an image or video file.'); }
    });


    function generateRandomHash(length = 8) {
        let result = '';
        for (let i = 0; i < length; i++) {
            result += latinBasicChars.charAt(Math.floor(Math.random() * latinBasicChars.length));
        }
        return result;
    }

    function downloadPng() {
        if (!outputCanvas || !currentBlobMatrix) return;
        const randomHash = generateRandomHash(8);
        const imgData = outputCanvas.toDataURL("image/png");
        const link = document.createElement('a');
        link.href = imgData; link.download = `Glyphtrix_image_${randomHash}.png`;
        document.body.appendChild(link); link.click(); document.body.removeChild(link);
    }
    function downloadText() {
      if (currentBlobMatrix) {
        const randomHash = generateRandomHash(8);
        let textToDownload = currentBlobMatrix.map(row => row.map(cell => cell.char).join('')).join('\n');
        const blob = new Blob([textToDownload], { type: "text/plain;charset=utf-8" });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob); link.download = `Glyphtrix_image_${randomHash}.txt`;
        document.body.appendChild(link); link.click(); document.body.removeChild(link);
      }
    }
   function openNewTab() {
       if (!outputCanvas || !currentBlobMatrix) return;
       
       outputCanvas.toBlob((blob) => {
           if (blob) {
               const blobUrl = URL.createObjectURL(blob);
               const newTab = window.open(blobUrl, '_blank');
               
               // Clean up the blob URL when the new tab is closed
               newTab.addEventListener('beforeunload', () => {
                   URL.revokeObjectURL(blobUrl);
               });
           }
       }, 'image/png');
   }
       function openGitHub() {
        window.open('https://github.com/LandoNikko/Glyphtrix', '_blank');
    }

    async function loadExampleImage() {
        try {
            loadingSpinner.style.display = 'inline';
            if (mobileLoadingSpinner) mobileLoadingSpinner.style.display = 'inline';
            showUploadSpinner();
            
            const response = await fetch('https://archive.org/download/324327main_4_full/324327main_4_full.jpg');
            if (!response.ok) throw new Error('Failed to fetch example image');
            
            const blob = await response.blob();
            const file = new File([blob], 'example-image.jpeg', { type: 'image/jpeg' });
            
            handleImageUpload(file);
            condensedUploadZone.style.display = 'inline-block';
            condensedFilename.innerHTML = `<i class="ri-check-line"></i> example-image.jpeg`;
            if(uploadPanelTitle) uploadPanelTitle.style.display = 'block';
        } catch (error) {
            console.error('Error loading example image:', error);
            alert('Failed to load example image. Please try again.');
        } finally {
            loadingSpinner.style.display = 'none';
            if (mobileLoadingSpinner) mobileLoadingSpinner.style.display = 'none';
            hideUploadSpinner();
        }
    }

    async function loadExampleVideo() {
        try {
            loadingSpinner.style.display = 'inline';
            if (mobileLoadingSpinner) mobileLoadingSpinner.style.display = 'inline';
            showUploadSpinner();
            
            // Try multiple CORS-enabled video URLs as fallbacks
            const videoUrls = [
            'http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ElephantsDream.mp4',
            ];
            
            let response = null;
            let videoUrl = null;
            
            for (const url of videoUrls) {
                try {
                    response = await fetch(url);
                    if (response.ok) {
                        videoUrl = url;
                        break;
                    }
                } catch (e) {
                    continue;
                }
            }
            
            if (!response || !response.ok) {
                throw new Error('All video sources are unavailable');
            }
            
            const blob = await response.blob();
            const file = new File([blob], 'example-video.mp4', { type: 'video/mp4' });
            
            handleImageUpload(file);
            condensedUploadZone.style.display = 'inline-block';
            condensedFilename.innerHTML = `<i class="ri-check-line"></i> example-video.mp4`;
            if(uploadPanelTitle) uploadPanelTitle.style.display = 'block';
        } catch (error) {
            console.error('Error loading example video:', error);
            alert('Failed to load example video. This may be due to network restrictions. Please try uploading your own video file instead.');
        } finally {
            loadingSpinner.style.display = 'none';
            if (mobileLoadingSpinner) mobileLoadingSpinner.style.display = 'none';
            hideUploadSpinner();
        }
    }

    function hideExampleButtons() {
        const exampleButtonsContainer = document.getElementById('exampleButtonsContainer');
        if (exampleButtonsContainer) {
            exampleButtonsContainer.style.display = 'none';
        }
        
        // Also hide any mobile example buttons
        const mobilePreviewContent = document.getElementById('mobilePreviewContent');
        if (mobilePreviewContent) {
            const mobileExampleButtons = mobilePreviewContent.querySelector('.example-buttons-container');
            if (mobileExampleButtons) {
                mobileExampleButtons.style.display = 'none';
            }
        }
    }

    function showExampleButtons() {
        const exampleButtonsContainer = document.getElementById('exampleButtonsContainer');
        if (exampleButtonsContainer) {
            exampleButtonsContainer.style.display = 'flex';
        }
    }

    function showUploadSpinner() {
        const uploadZone = document.getElementById('uploadZone');
        const uploadSpinner = document.getElementById('uploadSpinner');
        if (uploadZone && uploadSpinner) {
            uploadSpinner.innerHTML = getSpinner(48);
            uploadZone.classList.add('loading');
        }
    }

    function hideUploadSpinner() {
        const uploadZone = document.getElementById('uploadZone');
        if (uploadZone) {
            uploadZone.classList.remove('loading');
        }
    }

    function resetUploadState() {
        stopVideoProcessingLoop();
        clearCachedSequence();
        isVideoInput = false;
        currentMediaElement = null;
        originalPixelData = null;
        currentBlobMatrix = null;
        
        inputVideo.style.display = 'none';
        inputVideo.pause();
        inputVideo.src = "";
        inputCanvas.style.display = 'none';
        uploadZone.style.display = 'flex';
        
        showExampleButtons();
        
        condensedUploadZone.style.display = 'none';
        if(uploadPanelTitle) uploadPanelTitle.style.display = 'none';
        
        outputCanvas.width = 1;
        outputCanvas.height = 1;
        outputCtx.clearRect(0, 0, 1, 1);
        
        if(gridSizeDisplay) gridSizeDisplay.textContent = '-';
        if(outputResolutionDisplay) outputResolutionDisplay.textContent = '-';
        
        setDownloadButtonsState(true);
        updatePngSequenceButtonState();
        
        if(chromaRemovalContainer) chromaRemovalContainer.style.display = 'none';
        if(invertColorsContainer) invertColorsContainer.style.display = 'none';
        if(previewChangesContainer) previewChangesContainer.style.display = 'none';
        
        setDefaultValues();
        
        if (window.innerWidth <= 768 && mobilePreviewActive) {
            debouncedUpdateMobilePreview();
        }
    }

    function openInfoModal() {
        document.getElementById('infoModal').style.display = 'flex';
    }

    function closeInfoModal() {
        document.getElementById('infoModal').style.display = 'none';
    }

    function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    function formatDuration(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = Math.floor(seconds % 60);
        return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
    }



    function getVideoMetadata() {
        if (!inputVideo) return {};

        // Calculate output resolution based on current density and scale settings
        const density = parseInt(densityInput.value) || 7;
        const outputCols = Math.ceil(inputVideo.videoWidth / density);
        const outputRows = Math.ceil(inputVideo.videoHeight / density);
        const scaleFactor = parseFloat(scaleFactorInput.value) || 1;
        const charSize = 8 * scaleFactor;
        const outputWidth = outputCols * charSize;
        const outputHeight = outputRows * charSize;

        return {
            duration: inputVideo.duration ? formatDuration(inputVideo.duration) : 'Unknown',
            outputResolution: `${Math.round(outputWidth)} × ${Math.round(outputHeight)}`
        };
    }

    function calculateEstimatedFrames(fps) {
        if (!inputVideo || !inputVideo.duration) return 0;
        return Math.floor(inputVideo.duration * fps);
    }

    function populateVideoMetadata() {
        const metadataContainer = document.getElementById('videoMetadata');
        if (!metadataContainer) return;

        const metadata = getVideoMetadata();
        
        metadataContainer.innerHTML = `
            <div class="metadata-grid">
                <div class="metadata-item">
                    <span class="metadata-label">Duration</span>
                    <span class="metadata-value">${metadata.duration}</span>
                </div>
                <div class="metadata-item">
                    <span class="metadata-label">Resolution</span>
                    <span class="metadata-value">${metadata.outputResolution}</span>
                </div>
            </div>
        `;
    }

    function populateFpsOptions() {
        const fpsOptionsGrid = document.getElementById('fpsOptionsGrid');
        if (!fpsOptionsGrid) return;

        const fpsOptions = [
            { fps: 1, label: '1 FPS' },
            { fps: 2, label: '2 FPS' },
            { fps: 5, label: '5 FPS' },
            { fps: 24, label: '24 FPS' },
            { fps: 25, label: '25 FPS' },
            { fps: 30, label: '30 FPS' }
        ];

        fpsOptionsGrid.innerHTML = '';

        fpsOptions.forEach(option => {
            const estimatedFrames = calculateEstimatedFrames(option.fps);
            
            const button = document.createElement('button');
            button.className = 'fps-option-button';
            button.onclick = () => downloadPngSequenceWithFps(option.fps);

            button.innerHTML = `
                <div class="fps-number"><i class="ri-download-2-line"></i> ${option.label}</div>
                <div class="fps-description">${estimatedFrames.toLocaleString()} frames</div>
            `;

            fpsOptionsGrid.appendChild(button);
        });
        
        populateVideoMetadata();
    }

    function openFpsModal() {
        if (!isVideoInput || inputVideo.readyState < inputVideo.HAVE_METADATA || isSequenceRendering) return;
        populateFpsOptions();
        document.getElementById('fpsModal').style.display = 'flex';
    }

    function closeFpsModal() {
        document.getElementById('fpsModal').style.display = 'none';
    }

    // Close modal when clicking outside of it
    document.addEventListener('click', function(event) {
        const infoModal = document.getElementById('infoModal');
        const fpsModal = document.getElementById('fpsModal');
        if (event.target === infoModal) {
            closeInfoModal();
        }
        if (event.target === fpsModal) {
            closeFpsModal();
        }
    });

    // Close modal with Escape key
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
            closeInfoModal();
            closeFpsModal();
        }
    });

    function layoutPanels() {
        const isMobile = window.innerWidth <= 768;
        const isMediumScreen = window.innerWidth >= 769 && window.innerWidth <= 1600;
        const isDesktop = window.innerWidth >= 1601;
        
        desktopSettingsPanelContainer.style.display = isMobile ? 'none' : 'flex';
        mobileUploadPanelPlaceholder.style.display = isMobile ? 'flex' : 'none';
        mobileSettingsPanel.style.display = isMobile ? 'flex' : 'none';
        mobileDownloadPanelPlaceholder.style.display = isMobile ? 'flex' : 'none';

        if (isMobile) {
            if (uploadPanelContent.parentNode !== mobileUploadPanelPlaceholder) mobileUploadPanelPlaceholder.appendChild(uploadPanelContent);
            if (settingsTitleSection.parentNode !== mobileSettingsPanel) mobileSettingsPanel.appendChild(settingsTitleSection);
            if (imageSettingsContent.parentNode !== mobileSettingsPanel) mobileSettingsPanel.appendChild(imageSettingsContent);
            if (fontSettingsContent.parentNode !== mobileSettingsPanel) mobileSettingsPanel.appendChild(fontSettingsContent);
            if (outputSettingsContent.parentNode !== mobileSettingsPanel) mobileSettingsPanel.appendChild(outputSettingsContent);
            if (downloadPanelContent.parentNode !== mobileDownloadPanelPlaceholder) mobileDownloadPanelPlaceholder.appendChild(downloadPanelContent);
            
            // Let CSS handle mobile layout
            mainContainer.style.height = '';
        } else {
            desktopSettingsPanelContainer.appendChild(uploadPanelContent);
            desktopSettingsPanelContainer.appendChild(settingsTitleSection);
            desktopSettingsPanelContainer.appendChild(imageSettingsContent);
            desktopSettingsPanelContainer.appendChild(fontSettingsContent);
            desktopSettingsPanelContainer.appendChild(outputSettingsContent);
            desktopSettingsPanelContainer.appendChild(downloadPanelContent);
            
            if (isMediumScreen) {
                mainContainer.style.height = '';
                mainContainer.style.maxHeight = '';
            } else if (isDesktop) {
                requestAnimationFrame(() => {
                    const desktopHeight = desktopSettingsPanelContainer.offsetHeight || 200;
                    const minContainerHeight = Math.min(window.innerHeight - desktopHeight, window.innerHeight * 0.6);
                    mainContainer.style.height = `${Math.max(minContainerHeight, 600)}px`;
                    mainContainer.style.maxHeight = `calc(100vh - ${desktopHeight}px)`;
                });
            }
        }
    }




            let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (window.innerWidth > 768) {
                    destroyMobilePreview();
                }
                
                layoutPanels();
                
                if (window.innerWidth <= 768) {
                    initMobilePreview();
                }
                
                if (currentMediaElement || originalPixelData) {
                    setTimeout(() => {
                        processImageWithCurrentSettings();
                        if (!isVideoInput) updateInputCanvasPreview();
                    }, 100);
                }
            }, 300);
        });
    
    function scrambleText(element, originalText, duration = 250) {
        if (element.dataset.scrambling === 'true') return;
        
        element.dataset.scrambling = 'true';
        element.classList.add('scrambling');
        
        const uniqueChars = [...new Set(originalText.split(''))].filter(char => char !== ' ');
        const steps = 8;
        const stepDuration = duration / steps;
        let currentStep = 0;
        
        const scrambleInterval = setInterval(() => {
            if (currentStep < steps * 0.6) {
                const scrambled = originalText.split('').map((char, index) => {
                    if (char === ' ') return ' ';
                    if (Math.random() < 0.4) {
                        return uniqueChars[Math.floor(Math.random() * uniqueChars.length)];
                    }
                    return char;
                }).join('');
                element.textContent = scrambled;
            } else {
                const progress = (currentStep - steps * 0.6) / (steps * 0.4);
                const restored = originalText.split('').map((char, index) => {
                    if (char === ' ') return ' ';
                    if (Math.random() < progress * 0.8) {
                        return char;
                    }
                    return uniqueChars[Math.floor(Math.random() * uniqueChars.length)];
                }).join('');
                element.textContent = restored;
            }
            
            currentStep++;
            
            if (currentStep >= steps) {
                clearInterval(scrambleInterval);
                element.textContent = originalText;
                element.classList.remove('scrambling');
                element.dataset.scrambling = 'false';
            }
        }, stepDuration);
    }

    // Mobile preview panel functionality
    let mobilePreviewActive = false;
    let currentMobileView = 'input'; // 'input' or 'output'
    
    function initMobilePreview() {
        if (window.innerWidth > 768) return;
        
        const mobilePreviewPanel = document.getElementById('mobilePreviewPanel');
        const mobilePreviewSpacer = document.getElementById('mobilePreviewSpacer');
        const mobileInputToggle = document.getElementById('mobileInputToggle');
        const mobileOutputToggle = document.getElementById('mobileOutputToggle');
        const inputColumn = document.getElementById('inputColumn');
        const outputColumn = document.getElementById('outputColumn');
        
        if (!mobilePreviewPanel || !mobilePreviewSpacer) return;
        
        // Activate mobile preview by default
        mobilePreviewPanel.classList.add('active');
        mobilePreviewSpacer.classList.add('active');
        mobilePreviewActive = true;
        
        if (inputColumn) inputColumn.style.display = 'none';
        if (outputColumn) outputColumn.style.display = 'none';
        
        if (mobileInputToggle) {
            mobileInputToggle.addEventListener('click', () => switchMobileView('input'));
        }
        if (mobileOutputToggle) {
            mobileOutputToggle.addEventListener('click', () => switchMobileView('output'));
        }
        
        if (currentMediaElement) {
            currentMobileView = 'output';
            if (mobileInputToggle) mobileInputToggle.classList.remove('active');
            if (mobileOutputToggle) mobileOutputToggle.classList.add('active');
        } else {
            currentMobileView = 'input';
            if (mobileInputToggle) mobileInputToggle.classList.add('active');
            if (mobileOutputToggle) mobileOutputToggle.classList.remove('active');
        }
        
        updateMobilePreviewContent();
    }
    
    function switchMobileView(view) {
        if (currentMobileView === view) return;
        
        currentMobileView = view;
        
        const mobileInputToggle = document.getElementById('mobileInputToggle');
        const mobileOutputToggle = document.getElementById('mobileOutputToggle');
        
        if (mobileInputToggle && mobileOutputToggle) {
            mobileInputToggle.classList.toggle('active', view === 'input');
            mobileOutputToggle.classList.toggle('active', view === 'output');
        }
        
        const mobilePreviewContent = document.getElementById('mobilePreviewContent');
        if (mobilePreviewContent) {
            mobilePreviewContent.innerHTML = '';
        }
        updateMobilePreviewContent();
    }
    
    let mobilePreviewUpdateTimeout;
    function debouncedUpdateMobilePreview() {
        clearTimeout(mobilePreviewUpdateTimeout);
        mobilePreviewUpdateTimeout = setTimeout(() => {
            if (window.innerWidth <= 768 && mobilePreviewActive) {
                updateMobilePreviewContent();
            }
        }, 50);
    }

    function forceUpdateMobileOutputCanvas() {
        if (window.innerWidth <= 768 && mobilePreviewActive && currentMobileView === 'output') {
            const mobilePreviewContent = document.getElementById('mobilePreviewContent');
            if (mobilePreviewContent) {
                const existingContent = mobilePreviewContent.firstElementChild;
                if (existingContent && existingContent.tagName === 'CANVAS') {
                    const outputCanvas = document.getElementById('outputCanvas');
                    if (outputCanvas && currentBlobMatrix && currentBlobMatrix.length > 0) {
                        if (existingContent.width !== outputCanvas.width || existingContent.height !== outputCanvas.height) {
                            existingContent.width = outputCanvas.width;
                            existingContent.height = outputCanvas.height;
                        }
                        const ctx = existingContent.getContext('2d');
                        ctx.clearRect(0, 0, existingContent.width, existingContent.height);
                        ctx.drawImage(outputCanvas, 0, 0);
                    }
                }
            }
        }
    }

    function syncMobileVideoTime() {
        if (!mobilePreviewActive || window.innerWidth > 768 || currentMobileView !== 'input' || !isVideoInput) return;
        
        const mobilePreviewContent = document.getElementById('mobilePreviewContent');
        if (!mobilePreviewContent) return;
        
        const existingContent = mobilePreviewContent.firstElementChild;
        if (existingContent && existingContent.tagName === 'VIDEO') {
            const inputVideo = document.getElementById('inputVideo');
            if (inputVideo && Math.abs(existingContent.currentTime - inputVideo.currentTime) > 0.1) {
                existingContent.currentTime = inputVideo.currentTime;
            }
        }
    }

    // Track the current mobile video clone globally
    window.currentMobileVideoClone = null;
    window.currentMobileVideoCloneSeekedHandler = null;
    window.inputVideoSeekedHandler = null;

    function updateMobilePreviewContent() {
        if (!mobilePreviewActive || window.innerWidth > 768) return;
        
        const mobilePreviewContent = document.getElementById('mobilePreviewContent');
        if (!mobilePreviewContent) return;
        
        // Check if content already exists and is the correct type
        const existingContent = mobilePreviewContent.firstElementChild;
        const shouldUpdate = !existingContent || 
            (currentMobileView === 'input' && existingContent.tagName !== 'VIDEO' && existingContent.tagName !== 'CANVAS' && existingContent.id !== 'mobileUploadZone') ||
            (currentMobileView === 'output' && existingContent.tagName !== 'CANVAS' && !existingContent.style.cssText.includes('placeholder'));
        
        if (!shouldUpdate) {
            if (currentMobileView === 'input' && isVideoInput && existingContent.tagName === 'VIDEO') {
                syncMobileVideoTime();
            } else if (currentMobileView === 'output' && existingContent.tagName === 'CANVAS') {
                const outputCanvas = document.getElementById('outputCanvas');
                if (outputCanvas && currentBlobMatrix && currentBlobMatrix.length > 0) {
                    if (existingContent.width !== outputCanvas.width || existingContent.height !== outputCanvas.height) {
                        existingContent.width = outputCanvas.width;
                        existingContent.height = outputCanvas.height;
                    }
                    const ctx = existingContent.getContext('2d');
                    ctx.clearRect(0, 0, existingContent.width, existingContent.height);
                    ctx.drawImage(outputCanvas, 0, 0);
                }
            }
            return;
        }
        
        mobilePreviewContent.innerHTML = '';
        
        if (window.currentMobileVideoClone && window.currentMobileVideoCloneSeekedHandler) {
            window.currentMobileVideoClone.removeEventListener('seeked', window.currentMobileVideoCloneSeekedHandler);
            window.currentMobileVideoClone = null;
            window.currentMobileVideoCloneSeekedHandler = null;
        }
        if (window.inputVideoSeekedHandler && document.getElementById('inputVideo')) {
            document.getElementById('inputVideo').removeEventListener('seeked', window.inputVideoSeekedHandler);
            window.inputVideoSeekedHandler = null;
        }

        if (currentMobileView === 'input') {
            const inputCanvas = document.getElementById('inputCanvas');
            const inputVideo = document.getElementById('inputVideo');
            const uploadZone = document.getElementById('uploadZone');
            
            if (isVideoInput && inputVideo && inputVideo.style.display !== 'none') {
                const videoClone = inputVideo.cloneNode(true);
                videoClone.id = 'mobilePreviewVideo';
                videoClone.currentTime = inputVideo.currentTime;
                
                const videoCloneSeekedHandler = () => {
                    if (Math.abs(inputVideo.currentTime - videoClone.currentTime) > 0.1) {
                        inputVideo.currentTime = videoClone.currentTime;
                        const seekedEvent = new Event('seeked');
                        inputVideo.dispatchEvent(seekedEvent);
                    }
                };
                videoClone.addEventListener('seeked', videoCloneSeekedHandler);
                window.currentMobileVideoClone = videoClone;
                window.currentMobileVideoCloneSeekedHandler = videoCloneSeekedHandler;

                const inputVideoSeekedHandler = () => {
                    if (Math.abs(videoClone.currentTime - inputVideo.currentTime) > 0.1) {
                        videoClone.currentTime = inputVideo.currentTime;
                    }
                };
                inputVideo.addEventListener('seeked', inputVideoSeekedHandler);
                window.inputVideoSeekedHandler = inputVideoSeekedHandler;

                mobilePreviewContent.appendChild(videoClone);
            } else if (inputCanvas && inputCanvas.style.display !== 'none' && currentMediaElement) {
                const canvasClone = document.createElement('canvas');
                canvasClone.width = inputCanvas.width;
                canvasClone.height = inputCanvas.height;
                const ctx = canvasClone.getContext('2d');
                ctx.drawImage(inputCanvas, 0, 0);
                mobilePreviewContent.appendChild(canvasClone);
            } else if (uploadZone) {
                const uploadClone = uploadZone.cloneNode(true);
                uploadClone.id = 'mobileUploadZone';
                uploadClone.addEventListener('click', () => {
                    document.getElementById('imageUpload').click();
                });
                mobilePreviewContent.appendChild(uploadClone);
                
                // Add example buttons for mobile - positioned below upload zone
                const exampleButtonsContainer = document.getElementById('exampleButtonsContainer');
                if (exampleButtonsContainer && exampleButtonsContainer.style.display !== 'none' && !currentMediaElement && !originalPixelData) {
                    const mobileExampleButtons = exampleButtonsContainer.cloneNode(true);
                    mobileExampleButtons.style.cssText = `
                        display: flex;
                        gap: 10px;
                        margin-top: 15px;
                        justify-content: center;
                        width: 100%;
                        flex-direction: column;
                        align-items: center;
                    `;
                    mobileExampleButtons.querySelectorAll('button').forEach(button => {
                        button.style.cssText = `
                            min-width: 200px;
                            justify-content: center;
                            font-size: 0.9em;
                            padding: 8px 12px;
                            margin-bottom: 8px;
                        `;
                    });
                    mobilePreviewContent.appendChild(mobileExampleButtons);
                }
            }
        } else {
            const outputCanvas = document.getElementById('outputCanvas');
            if (outputCanvas && currentBlobMatrix && currentBlobMatrix.length > 0) {
                const canvasClone = document.createElement('canvas');
                canvasClone.width = outputCanvas.width;
                canvasClone.height = outputCanvas.height;
                const ctx = canvasClone.getContext('2d');
                ctx.drawImage(outputCanvas, 0, 0);
                mobilePreviewContent.appendChild(canvasClone);
            } else {
                const placeholder = document.createElement('div');
                placeholder.style.cssText = `
                    display: flex; 
                    align-items: center; 
                    justify-content: center; 
                    height: 200px; 
                    color: var(--muted-grey); 
                    font-size: 1.2em;
                    text-align: center;
                `;
                placeholder.textContent = 'Select "Input" to upload an image or video';
                mobilePreviewContent.appendChild(placeholder);
            }
        }
    }
    
    function showDesktopLayout() {
        const inputColumn = document.getElementById('inputColumn');
        const outputColumn = document.getElementById('outputColumn');
        
        if (inputColumn) inputColumn.style.display = 'flex';
        if (outputColumn) outputColumn.style.display = 'flex';
    }
    
    function hideMobilePreview() {
        const mobilePreviewPanel = document.getElementById('mobilePreviewPanel');
        const mobilePreviewSpacer = document.getElementById('mobilePreviewSpacer');
        
        if (mobilePreviewPanel) mobilePreviewPanel.classList.remove('active');
        if (mobilePreviewSpacer) mobilePreviewSpacer.classList.remove('active');
    }

    function destroyMobilePreview() {
        const mobilePreviewPanel = document.getElementById('mobilePreviewPanel');
        const mobilePreviewSpacer = document.getElementById('mobilePreviewSpacer');
        const mobilePreviewContent = document.getElementById('mobilePreviewContent');
        
        if (mobilePreviewContent) {
            mobilePreviewContent.innerHTML = '';
        }
        
        const mobileInputToggle = document.getElementById('mobileInputToggle');
        const mobileOutputToggle = document.getElementById('mobileOutputToggle');
        
        if (currentMediaElement) {
            currentMobileView = 'output';
            if (mobileInputToggle) mobileInputToggle.classList.remove('active');
            if (mobileOutputToggle) mobileOutputToggle.classList.add('active');
        } else {
            currentMobileView = 'input';
            if (mobileInputToggle) mobileInputToggle.classList.add('active');
            if (mobileOutputToggle) mobileOutputToggle.classList.remove('active');
        }
        
        hideMobilePreview();
        showDesktopLayout();
        
        mobilePreviewActive = false;
    }

    document.addEventListener('DOMContentLoaded', () => {
        loadingSpinner.innerHTML = getSpinner(24);
        if (mobileLoadingSpinner) mobileLoadingSpinner.innerHTML = getSpinner(24);
        const sequenceSpinner = document.getElementById('sequenceLoadingSpinner');
        if (sequenceSpinner) sequenceSpinner.innerHTML = getSpinner(64);
        
        availableFonts.forEach(font => {
            const option = document.createElement('option');
            option.value = font.cssName;
            option.textContent = font.name;
            fontSelect.appendChild(option);
        });
        setDefaultValues();
        if(uploadPanelTitle) uploadPanelTitle.style.display = 'none';
        layoutPanels();
        updatePngSequenceButtonState();
        
        setTimeout(() => {
            if (window.innerWidth <= 768) {
                initMobilePreview();
            } else {
                showDesktopLayout();
            }
        }, 100);
        


        const glyphtrixLogo = document.getElementById('glyphtrixLogo');
        if (glyphtrixLogo) {
            glyphtrixLogo.addEventListener('mouseenter', () => {
                scrambleText(glyphtrixLogo, 'GLYPHTRIX');
            });
            glyphtrixLogo.addEventListener('click', () => {
                location.reload();
            });
        }
        
        if (window.innerWidth > 768) {
            showDesktopLayout();
        }
    });
    inputCanvas.style.display = 'none';
  </script>

</body>
</html>